<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 8 章 查找算法 | Hello VuePress</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.80b48331.css" as="style"><link rel="preload" href="/assets/js/app.b653f105.js" as="script"><link rel="preload" href="/assets/js/2.99d1a617.js" as="script"><link rel="preload" href="/assets/js/20.89b76482.js" as="script"><link rel="prefetch" href="/assets/js/10.800b72c9.js"><link rel="prefetch" href="/assets/js/11.57accf41.js"><link rel="prefetch" href="/assets/js/12.13fbcf8c.js"><link rel="prefetch" href="/assets/js/13.4d2d664d.js"><link rel="prefetch" href="/assets/js/14.910991c0.js"><link rel="prefetch" href="/assets/js/15.1313f354.js"><link rel="prefetch" href="/assets/js/16.6db479e6.js"><link rel="prefetch" href="/assets/js/17.2f448bc3.js"><link rel="prefetch" href="/assets/js/18.30dabd53.js"><link rel="prefetch" href="/assets/js/19.d2eaaaad.js"><link rel="prefetch" href="/assets/js/21.c3198162.js"><link rel="prefetch" href="/assets/js/22.f98eeba2.js"><link rel="prefetch" href="/assets/js/23.b9aba8a3.js"><link rel="prefetch" href="/assets/js/24.3e956e2a.js"><link rel="prefetch" href="/assets/js/25.b1b78e1c.js"><link rel="prefetch" href="/assets/js/26.cf1a8b48.js"><link rel="prefetch" href="/assets/js/27.d5bfcc65.js"><link rel="prefetch" href="/assets/js/28.953cb79b.js"><link rel="prefetch" href="/assets/js/29.8a492853.js"><link rel="prefetch" href="/assets/js/3.3388cb9e.js"><link rel="prefetch" href="/assets/js/30.b01648fa.js"><link rel="prefetch" href="/assets/js/31.4e91fc6c.js"><link rel="prefetch" href="/assets/js/32.4bbadcf2.js"><link rel="prefetch" href="/assets/js/33.d052232e.js"><link rel="prefetch" href="/assets/js/34.33e965c9.js"><link rel="prefetch" href="/assets/js/35.0ddaddcd.js"><link rel="prefetch" href="/assets/js/36.edb41847.js"><link rel="prefetch" href="/assets/js/37.8e9c2d1f.js"><link rel="prefetch" href="/assets/js/4.dc746784.js"><link rel="prefetch" href="/assets/js/5.d434ae10.js"><link rel="prefetch" href="/assets/js/6.7eb90bfc.js"><link rel="prefetch" href="/assets/js/7.041e9117.js"><link rel="prefetch" href="/assets/js/8.9ce2df1b.js"><link rel="prefetch" href="/assets/js/9.e3ac39ca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.80b48331.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hello VuePress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/pages/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue学习" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  Vue入门
</a></li><li class="dropdown-item"><!----> <a href="/pages/Vue/进阶.html" class="nav-link">
  Vue进阶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JAVA学习" class="dropdown-title"><span class="title">JAVA</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  JAVA
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/JavaWeb/" class="nav-link">
  JAVAWeb
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/数据结构与算法/" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MySQL学习" class="dropdown-title"><span class="title">MySQL</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/MySQL/" class="nav-link">
  MySQL
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/pages/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue学习" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  Vue入门
</a></li><li class="dropdown-item"><!----> <a href="/pages/Vue/进阶.html" class="nav-link">
  Vue进阶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JAVA学习" class="dropdown-title"><span class="title">JAVA</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  JAVA
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/JavaWeb/" class="nav-link">
  JAVAWeb
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/数据结构与算法/" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MySQL学习" class="dropdown-title"><span class="title">MySQL</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/MySQL/" class="nav-link">
  MySQL
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/pages/JavaScript/" class="sidebar-heading clickable"><span>JavaScript</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JavaScript/day10.html" class="sidebar-link">对象&amp;函数</a></li><li><a href="/pages/JavaScript/day11.html" class="sidebar-link">知道</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/Vue/" class="sidebar-heading clickable"><span>Vue学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Vue/入门.html" class="sidebar-link">Vue入门</a></li><li><a href="/pages/Vue/进阶.html" class="sidebar-link">Vue进阶</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/JAVA/JavaWeb/" class="sidebar-heading clickable"><span>JavaWeb</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JAVA/JavaWeb/Servlet&amp;Request&amp;案例.html" class="sidebar-link">Servlet&amp;Request</a></li><li><a href="/pages/JAVA/JavaWeb/Response.html" class="sidebar-link">Response</a></li><li><a href="/pages/JAVA/JavaWeb/Cookie&amp;Session笔记.html" class="sidebar-link">Cookie&amp;Session</a></li><li><a href="/pages/JAVA/JavaWeb/EL&amp;JSTL笔记.html" class="sidebar-link">EL&amp;STL</a></li><li><a href="/pages/JAVA/JavaWeb/Filter&amp;Listener笔记.html" class="sidebar-link">Filter&amp;Listener</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/JAVA/数据结构与算法/" class="sidebar-heading clickable open"><span>数据结构与算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JAVA/数据结构与算法/第一章.html" class="sidebar-link">一、内容介绍</a></li><li><a href="/pages/JAVA/数据结构与算法/第二章.html" class="sidebar-link">二、数据结构和算法关系</a></li><li><a href="/pages/JAVA/数据结构与算法/第三章.html" class="sidebar-link">三、稀疏数组和队列</a></li><li><a href="/pages/JAVA/数据结构与算法/第四章.html" class="sidebar-link">四、链表</a></li><li><a href="/pages/JAVA/数据结构与算法/第五章.html" class="sidebar-link">五、栈</a></li><li><a href="/pages/JAVA/数据结构与算法/第六章.html" class="sidebar-link">六、递归</a></li><li><a href="/pages/JAVA/数据结构与算法/第七章.html" class="sidebar-link">七、排序</a></li><li><a href="/pages/JAVA/数据结构与算法/第八章.html" class="active sidebar-link">八、查找</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第八章.html#_8-1-查找算法介绍" class="sidebar-link">8.1 查找算法介绍</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第八章.html#_8-2-线性查找算法" class="sidebar-link">8.2 线性查找算法</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第八章.html#_8-3-二分查找算法" class="sidebar-link">8.3 二分查找算法</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第八章.html#_8-4-插值查找算法" class="sidebar-link">8.4 插值查找算法</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第八章.html#_8-5-斐波那契-黄金分割法-查找算法" class="sidebar-link">8.5 斐波那契(黄金分割法)查找算法</a></li></ul></li><li><a href="/pages/JAVA/数据结构与算法/第九章.html" class="sidebar-link">九、哈希表</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/MySQL/" class="sidebar-heading clickable"><span>MySQL</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/MySQL/day01.html" class="sidebar-link">MySQL基本命令</a></li><li><a href="/pages/MySQL/day02.html" class="sidebar-link">MySQL入门</a></li><li><a href="/pages/MySQL/day03.html" class="sidebar-link">MySQL基础</a></li><li><a href="/pages/MySQL/day04.html" class="sidebar-link">MySQL进阶</a></li><li><a href="/pages/MySQL/lesson.html" class="sidebar-link">练习题34道</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第-8-章-查找算法"><a href="#第-8-章-查找算法" class="header-anchor">#</a> 第 8 章 查找算法</h1> <h2 id="_8-1-查找算法介绍"><a href="#_8-1-查找算法介绍" class="header-anchor">#</a> 8.1 查找算法介绍</h2> <div class="language- extra-class"><pre><code>在 java 中，我们常用的查找有四种:
 1) 顺序(线性)查找
 2) 二分查找/折半查找
 3) 插值查找
 4) 斐波那契查找
</code></pre></div><h2 id="_8-2-线性查找算法"><a href="#_8-2-线性查找算法" class="header-anchor">#</a> 8.2 线性查找算法</h2> <div class="language- extra-class"><pre><code>有一个数列： {1,8 10, 89, 10, 1234} ，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提
示找到，并给出下标值。
代码实现：
public class SeqSearch {

	public static void main(String[] args) {
		int arr[] = { 1, 9, 11, -1, 34, 89 };// 没有顺序的数组
		int index = seqSearch(arr, -11);
		if(index == -1) {
			System.out.println(&quot;没有找到到&quot;);
		} else {
			System.out.println(&quot;找到，下标为=&quot; + index);
		}
	}

	/**
	 * 这里我们实现的线性查找是找到一个满足条件的值，就返回
	 * @param arr
	 * @param value
	 * @return
	 */
	public static int seqSearch(int[] arr, int value) {
		// 线性查找是逐一比对，发现有相同值，就返回下标
		for (int i = 0; i &lt; arr.length; i++) {
			if(arr[i] == value) {
				return i;
			}
		}
		return -1;
	}

}
</code></pre></div><h2 id="_8-3-二分查找算法"><a href="#_8-3-二分查找算法" class="header-anchor">#</a> 8.3 二分查找算法</h2> <h3 id="_8-3-1二分查找："><a href="#_8-3-1二分查找：" class="header-anchor">#</a> 8.3.1二分查找：</h3> <div class="language- extra-class"><pre><code>   请对一个有序数组进行二分查找 {1,8 10, 89, 10, 1234} ，输入一个数看该数组是否存在此数，并且求出下
标，如果没有就提示&quot;没有这个数&quot;。
</code></pre></div><h3 id="_8-3-2二分查找算法的思路"><a href="#_8-3-2二分查找算法的思路" class="header-anchor">#</a> 8.3.2二分查找算法的思路</h3> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/1.jpg" alt="二分查找思路"></p> <h3 id="_8-3-3二分查找的代码"><a href="#_8-3-3二分查找的代码" class="header-anchor">#</a> 8.3.3二分查找的代码</h3> <div class="language- extra-class"><pre><code>说明：增加了找到所有的满足条件的元素下标:
课后思考题： {1,8 10, 89, 10, 10，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数都查找到

public class BinarySearch {
    public static void main(String[] args) {
        int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };
//        int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 };

    }
    // 二分查找算法
    /**
     *
     * @param arr
     *            数组
     * @param left
     *            左边的索引
     * @param right
     *            右边的索引
     * @param findVal
     *            要查找的值
     * @return 如果找到就返回下标，如果没有找到，就返回 -1
     */
    public static int binarySearch(int[] arr, int left, int right, int findVal) {


        // 当 left &gt; right 时，说明递归整个数组，但是没有找到
        if (left &gt; right){
            return -1;
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if (findVal &gt; midVal){
            return binarySearch(arr,mid + 1,right,findVal);
        }else if (findVal &lt; midVal){
            return binarySearch(arr, left, mid - 1, findVal);
        }else {
            return mid;
        }

    }

    //完成一个课后思考题:
    /*
     * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，
     * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000
     *
     * 思路分析
     * 1. 在找到mid 索引值，不要马上返回
     * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
     * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
     * 4. 将Arraylist返回
     */

    package com.lyg.eight;
    
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @program: DataStructure
     * @description:
     * @author: LvYangai
     * @create: 2020-07-05 15:49
     * @e-mail: 1076977275@qq.com
     **/
    public class BinarySearch {
        public static void main(String[] args) {
            int arr[] = { 1, 8, 1000,1000, 89,1000,1000, 1234 };
    //        int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 };
            List&lt;Integer&gt; resIndexList = binarySearch2(arr, 0, arr.length - 1, 1000);
            System.out.println(&quot;resIndexList=&quot; + resIndexList);
    
        }
        // 二分查找算法
        /**
         *
         * @param arr
         *            数组
         * @param left
         *            左边的索引
         * @param right
         *            右边的索引
         * @param findVal
         *            要查找的值
         * @return 如果找到就返回下标，如果没有找到，就返回 -1
         */
        public static int binarySearch(int[] arr, int left, int right, int findVal) {
    
    
            // 当 left &gt; right 时，说明递归整个数组，但是没有找到
            if (left &gt; right){
                return -1;
            }
            int mid = (left + right) / 2;
            int midVal = arr[mid];
            if (findVal &gt; midVal){
                return binarySearch(arr,mid + 1,right,findVal);
            }else if (findVal &lt; midVal){
                return binarySearch(arr, left, mid - 1, findVal);
            }else {
                return mid;
            }
    
        }
    
        //完成一个课后思考题:
        /*
         * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，
         * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000
         *
         * 思路分析
         * 1. 在找到mid 索引值，不要马上返回
         * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
         * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
         * 4. 将Arraylist返回
         */
    
        public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) {
    
            System.out.println(&quot;hello~&quot;);
            // 当 left &gt; right 时，说明递归整个数组，但是没有找到
            if (left &gt; right) {
                return new ArrayList&lt;Integer&gt;();
            }
            int mid = (left + right) / 2;
            int midVal = arr[mid];
    
            if (findVal &gt; midVal) { // 向 右递归
                return binarySearch2(arr, mid + 1, right, findVal);
            } else if (findVal &lt; midVal) { // 向左递归
                return binarySearch2(arr, left, mid - 1, findVal);
            } else {
    //			 * 思路分析
    //			 * 1. 在找到mid 索引值，不要马上返回
    //			 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
    //			 * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
    //			 * 4. 将Arraylist返回
    
                List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;();
                //向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
                int temp = mid - 1;
                while(temp &gt;= 0) {
                    if (arr[temp] != findVal) {//退出
                        temp -= 1;
                        continue;
                    }
                    //否则，就temp 放入到 resIndexlist
                    resIndexlist.add(temp);
                    temp -= 1; //temp左移
                }
                resIndexlist.add(mid);  //
    
                //向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
                temp = mid + 1;
                while(temp &lt; arr.length) {
                    if (arr[temp] != findVal) {//退出
                        temp += 1;
                        continue;
                    }
                    //否则，就temp 放入到 resIndexlist
                    resIndexlist.add(temp);
                    temp += 1; //temp右移
                }
    
                return resIndexlist;
            }
    
        }
    }
</code></pre></div><h2 id="_8-4-插值查找算法"><a href="#_8-4-插值查找算法" class="header-anchor">#</a> 8.4 插值查找算法</h2> <div class="language- extra-class"><pre><code>1)插值查找原理介绍:
 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。
2)将折半查找中的求 mid 索引的公式, low表示左边索引left, high表示右边索引right. 
 key就是前面我们讲的findVal
</code></pre></div><p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/2.jpg" alt="插值公式">
3) int mid = low + (high-low) *(key - arr[low]) / (arr[high] - arr[low])
对应前面的代码公式：
int mid = left+(right–left)  *  (findVal – arr[left]) / (arr[right] – arr[left])
4) 举例说明插值查找算法 1-100 的数组
<img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/3.jpg" alt="插值算法举例说明"></p> <h3 id="_8-4-1插值查找应用案例："><a href="#_8-4-1插值查找应用案例：" class="header-anchor">#</a> 8.4.1插值查找应用案例：</h3> <div class="language- extra-class"><pre><code> 请对一个有序数组进行插值查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下 
标，如果没有就提示&quot;没有这个数&quot;。

代码实现:

public class InsertValueSearch {

    public static void main(String[] args) {

//		int [] arr = new int[100];
//		for(int i = 0; i &lt; 100; i++) {
//			arr[i] = i + 1;
//		}

        int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };

        int index = insertValueSearch(arr, 0, arr.length - 1, 1234);
        //int index = binarySearch(arr, 0, arr.length, 1);
        System.out.println(&quot;index = &quot; + index);

        //System.out.println(Arrays.toString(arr));
    }

    public static int binarySearch(int[] arr, int left, int right, int findVal) {
        System.out.println(&quot;二分查找被调用~&quot;);
        // 当 left &gt; right 时，说明递归整个数组，但是没有找到
        if (left &gt; right) {
            return -1;
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (findVal &gt; midVal) { // 向 右递归
            return binarySearch(arr, mid + 1, right, findVal);
        } else if (findVal &lt; midVal) { // 向左递归
            return binarySearch(arr, left, mid - 1, findVal);
        } else {

            return mid;
        }

    }

    //编写插值查找算法
    //说明：插值查找算法，也要求数组是有序的
    /**
     *
     * @param arr 数组
     * @param left 左边索引
     * @param right 右边索引
     * @param findVal 查找值
     * @return 如果找到，就返回对应的下标，如果没有找到，返回-1
     */
    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {

        System.out.println(&quot;插值查找次数~~&quot;);

        //注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要
        //否则我们得到的 mid 可能越界
        if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) {
            return -1;
        }

        // 求出mid, 自适应
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal &gt; midVal) { // 说明应该向右边递归
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal &lt; midVal) { // 说明向左递归查找
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }

    }
}
</code></pre></div><h3 id="_8-4-2插值查找注意事项："><a href="#_8-4-2插值查找注意事项：" class="header-anchor">#</a> 8.4.2插值查找注意事项：</h3> <div class="language- extra-class"><pre><code> 1) 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找,    速度较快. 
 2) 关键字分布不均匀的情况下，该方法不一定比折半查找要好
</code></pre></div><h2 id="_8-5-斐波那契-黄金分割法-查找算法"><a href="#_8-5-斐波那契-黄金分割法-查找算法" class="header-anchor">#</a> 8.5 斐波那契(黄金分割法)查找算法</h2> <h3 id="_8-5-1斐波那契-黄金分割法-查找基本介绍"><a href="#_8-5-1斐波那契-黄金分割法-查找基本介绍" class="header-anchor">#</a> 8.5.1斐波那契(黄金分割法)查找基本介绍:</h3> <div class="language- extra-class"><pre><code>1) 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 
数字的近似值是  0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神
奇的数字，会带来意向不大的效果。
2) 斐波那契数列    {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数
的比例，无限接近    黄金分割值 0.618
</code></pre></div><h3 id="_8-5-2斐波那契-黄金分割法-原理"><a href="#_8-5-2斐波那契-黄金分割法-原理" class="header-anchor">#</a> 8.5.2斐波那契(黄金分割法)原理:</h3> <div class="language- extra-class"><pre><code>   斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid  
不再是中间或插值得到，而是位 于黄金分割点附近，即  mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示
</code></pre></div><p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/4.jpg" alt="斐波那契查找">
对 F(k-1)-1 的理解：
1) 由斐波那契数列F[k]=F[k-1]+F[k-2]的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1。
该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。
从而中间位置为 mid=low+F(k-1)-1
2) 类似的，每一子段也可以用相同的方式分割
3) 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使
得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1到F[k]-1 位置），
都赋为 n 位置的值即可。
while(n&gt;fib(k)-1)
k++;</p> <h3 id="_8-5-3斐波那契查找应用案例："><a href="#_8-5-3斐波那契查找应用案例：" class="header-anchor">#</a> 8.5.3斐波那契查找应用案例：</h3> <div class="language- extra-class"><pre><code>请对一个有序数组进行斐波那契查找{1,8,10,89,1000,1234}，输入一个数看看该数组是否存在此数，并且求 
出下标，如果没有就提示&quot;没有这个数&quot;。 
代码实现:

public class FibonacciSearch {

	public static int maxSize = 20;
	public static void main(String[] args) {
		int [] arr = {1,8, 10, 89, 1000, 1234};
		
		System.out.println(&quot;index=&quot; + fibSearch(arr, 189));// 0
		
	}

	//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
	//非递归方法得到一个斐波那契数列
	public static int[] fib() {
		int[] f = new int[maxSize];
		f[0] = 1;
		f[1] = 1;
		for (int i = 2; i &lt; maxSize; i++) {
			f[i] = f[i - 1] + f[i - 2];
		}
		return f;
	}
	
	//编写斐波那契查找算法
	//使用非递归的方式编写算法
	/**
	 * 
	 * @param a  数组
	 * @param key 我们需要查找的关键码(值)
	 * @return 返回对应的下标，如果没有-1
	 */
	public static int fibSearch(int[] a, int key) {
		int low = 0;
		int high = a.length - 1;
		int k = 0; //表示斐波那契分割数值的下标
		int mid = 0; //存放mid值
		int f[] = fib(); //获取到斐波那契数列
		//获取到斐波那契分割数值的下标
		while(high &gt; f[k] - 1) {
			k++;
		}
		//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]
		//不足的部分会使用0填充
		int[] temp = Arrays.copyOf(a, f[k]);
		//实际上需求使用a数组最后的数填充 temp
		//举例:
		//temp = {1,8, 10, 89, 1000, 1234, 0, 0}  =&gt; {1,8, 10, 89, 1000, 1234, 1234, 1234,}
		for(int i = high + 1; i &lt; temp.length; i++) {
			temp[i] = a[high];
		}
		
		// 使用while来循环处理，找到我们的数 key
		while (low &lt;= high) { // 只要这个条件满足，就可以找
			mid = low + f[k - 1] - 1;
			if(key &lt; temp[mid]) { //我们应该继续向数组的前面查找(左边)
				high = mid - 1;
				//为甚是 k--
				//说明
				//1. 全部元素 = 前面的元素 + 后边元素
				//2. f[k] = f[k-1] + f[k-2]
				//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]
				//即 在 f[k-1] 的前面继续查找 k--
				//即下次循环 mid = f[k-1-1]-1
				k--;
			} else if ( key &gt; temp[mid]) { // 我们应该继续向数组的后面查找(右边)
				low = mid + 1;
				//为什么是k -=2
				//说明
				//1. 全部元素 = 前面的元素 + 后边元素
				//2. f[k] = f[k-1] + f[k-2]
				//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]
				//4. 即在f[k-2] 的前面进行查找 k -=2
				//5. 即下次循环 mid = f[k - 1 - 2] - 1
				k -= 2;
			} else { //找到
				//需要确定，返回的是哪个下标
				if(mid &lt;= high) {
					return mid;
				} else {
					return high;
				}
			}
		}
		return -1;
	}
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/JAVA/数据结构与算法/第七章.html" class="prev">
        七、排序
      </a></span> <span class="next"><a href="/pages/JAVA/数据结构与算法/第九章.html">
        九、哈希表
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b653f105.js" defer></script><script src="/assets/js/2.99d1a617.js" defer></script><script src="/assets/js/20.89b76482.js" defer></script>
  </body>
</html>
