<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 4 章 链表 | Hello VuePress</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.80b48331.css" as="style"><link rel="preload" href="/assets/js/app.b653f105.js" as="script"><link rel="preload" href="/assets/js/2.99d1a617.js" as="script"><link rel="preload" href="/assets/js/22.f98eeba2.js" as="script"><link rel="prefetch" href="/assets/js/10.800b72c9.js"><link rel="prefetch" href="/assets/js/11.57accf41.js"><link rel="prefetch" href="/assets/js/12.13fbcf8c.js"><link rel="prefetch" href="/assets/js/13.4d2d664d.js"><link rel="prefetch" href="/assets/js/14.910991c0.js"><link rel="prefetch" href="/assets/js/15.1313f354.js"><link rel="prefetch" href="/assets/js/16.6db479e6.js"><link rel="prefetch" href="/assets/js/17.2f448bc3.js"><link rel="prefetch" href="/assets/js/18.30dabd53.js"><link rel="prefetch" href="/assets/js/19.d2eaaaad.js"><link rel="prefetch" href="/assets/js/20.89b76482.js"><link rel="prefetch" href="/assets/js/21.c3198162.js"><link rel="prefetch" href="/assets/js/23.b9aba8a3.js"><link rel="prefetch" href="/assets/js/24.3e956e2a.js"><link rel="prefetch" href="/assets/js/25.b1b78e1c.js"><link rel="prefetch" href="/assets/js/26.cf1a8b48.js"><link rel="prefetch" href="/assets/js/27.d5bfcc65.js"><link rel="prefetch" href="/assets/js/28.953cb79b.js"><link rel="prefetch" href="/assets/js/29.8a492853.js"><link rel="prefetch" href="/assets/js/3.3388cb9e.js"><link rel="prefetch" href="/assets/js/30.b01648fa.js"><link rel="prefetch" href="/assets/js/31.4e91fc6c.js"><link rel="prefetch" href="/assets/js/32.4bbadcf2.js"><link rel="prefetch" href="/assets/js/33.d052232e.js"><link rel="prefetch" href="/assets/js/34.33e965c9.js"><link rel="prefetch" href="/assets/js/35.0ddaddcd.js"><link rel="prefetch" href="/assets/js/36.edb41847.js"><link rel="prefetch" href="/assets/js/37.8e9c2d1f.js"><link rel="prefetch" href="/assets/js/4.dc746784.js"><link rel="prefetch" href="/assets/js/5.d434ae10.js"><link rel="prefetch" href="/assets/js/6.7eb90bfc.js"><link rel="prefetch" href="/assets/js/7.041e9117.js"><link rel="prefetch" href="/assets/js/8.9ce2df1b.js"><link rel="prefetch" href="/assets/js/9.e3ac39ca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.80b48331.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hello VuePress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/pages/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue学习" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  Vue入门
</a></li><li class="dropdown-item"><!----> <a href="/pages/Vue/进阶.html" class="nav-link">
  Vue进阶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JAVA学习" class="dropdown-title"><span class="title">JAVA</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  JAVA
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/JavaWeb/" class="nav-link">
  JAVAWeb
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/数据结构与算法/" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MySQL学习" class="dropdown-title"><span class="title">MySQL</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/MySQL/" class="nav-link">
  MySQL
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/pages/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue学习" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  Vue入门
</a></li><li class="dropdown-item"><!----> <a href="/pages/Vue/进阶.html" class="nav-link">
  Vue进阶
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JAVA学习" class="dropdown-title"><span class="title">JAVA</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Vue/入门.html" class="nav-link">
  JAVA
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/JavaWeb/" class="nav-link">
  JAVAWeb
</a></li><li class="dropdown-item"><!----> <a href="/pages/JAVA/数据结构与算法/" class="nav-link">
  数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="MySQL学习" class="dropdown-title"><span class="title">MySQL</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/MySQL/" class="nav-link">
  MySQL
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/pages/JavaScript/" class="sidebar-heading clickable"><span>JavaScript</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JavaScript/day10.html" class="sidebar-link">对象&amp;函数</a></li><li><a href="/pages/JavaScript/day11.html" class="sidebar-link">知道</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/Vue/" class="sidebar-heading clickable"><span>Vue学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Vue/入门.html" class="sidebar-link">Vue入门</a></li><li><a href="/pages/Vue/进阶.html" class="sidebar-link">Vue进阶</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/JAVA/JavaWeb/" class="sidebar-heading clickable"><span>JavaWeb</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JAVA/JavaWeb/Servlet&amp;Request&amp;案例.html" class="sidebar-link">Servlet&amp;Request</a></li><li><a href="/pages/JAVA/JavaWeb/Response.html" class="sidebar-link">Response</a></li><li><a href="/pages/JAVA/JavaWeb/Cookie&amp;Session笔记.html" class="sidebar-link">Cookie&amp;Session</a></li><li><a href="/pages/JAVA/JavaWeb/EL&amp;JSTL笔记.html" class="sidebar-link">EL&amp;STL</a></li><li><a href="/pages/JAVA/JavaWeb/Filter&amp;Listener笔记.html" class="sidebar-link">Filter&amp;Listener</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/JAVA/数据结构与算法/" class="sidebar-heading clickable open"><span>数据结构与算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JAVA/数据结构与算法/第一章.html" class="sidebar-link">一、内容介绍</a></li><li><a href="/pages/JAVA/数据结构与算法/第二章.html" class="sidebar-link">二、数据结构和算法关系</a></li><li><a href="/pages/JAVA/数据结构与算法/第三章.html" class="sidebar-link">三、稀疏数组和队列</a></li><li><a href="/pages/JAVA/数据结构与算法/第四章.html" class="active sidebar-link">四、链表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-1-链表-linked-list-介绍" class="sidebar-link">4.1 链表(Linked List)介绍</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-2-单链表的应用实例" class="sidebar-link">4.2 单链表的应用实例</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-3-单链表面试题-新浪、百度、腾讯" class="sidebar-link">4.3 单链表面试题(新浪、百度、腾讯)</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-双向链表应用实例" class="sidebar-link">4. 双向链表应用实例</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-5-单向环形链表应用场景" class="sidebar-link">4.5 单向环形链表应用场景</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-7-josephu-问题" class="sidebar-link">4.7 Josephu 问题</a></li><li class="sidebar-sub-header"><a href="/pages/JAVA/数据结构与算法/第四章.html#_4-8-josephu-问题的代码实现" class="sidebar-link">4.8 Josephu 问题的代码实现</a></li></ul></li><li><a href="/pages/JAVA/数据结构与算法/第五章.html" class="sidebar-link">五、栈</a></li><li><a href="/pages/JAVA/数据结构与算法/第六章.html" class="sidebar-link">六、递归</a></li><li><a href="/pages/JAVA/数据结构与算法/第七章.html" class="sidebar-link">七、排序</a></li><li><a href="/pages/JAVA/数据结构与算法/第八章.html" class="sidebar-link">八、查找</a></li><li><a href="/pages/JAVA/数据结构与算法/第九章.html" class="sidebar-link">九、哈希表</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/pages/MySQL/" class="sidebar-heading clickable"><span>MySQL</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/MySQL/day01.html" class="sidebar-link">MySQL基本命令</a></li><li><a href="/pages/MySQL/day02.html" class="sidebar-link">MySQL入门</a></li><li><a href="/pages/MySQL/day03.html" class="sidebar-link">MySQL基础</a></li><li><a href="/pages/MySQL/day04.html" class="sidebar-link">MySQL进阶</a></li><li><a href="/pages/MySQL/lesson.html" class="sidebar-link">练习题34道</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第-4-章-链表"><a href="#第-4-章-链表" class="header-anchor">#</a> 第 4 章 链表</h1> <h2 id="_4-1-链表-linked-list-介绍"><a href="#_4-1-链表-linked-list-介绍" class="header-anchor">#</a> 4.1 链表(Linked List)介绍</h2> <p>链表是有序的列表，但是它在内存中是存储如下</p> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/1.jpg" alt="链表"></p> <blockquote><p>小结上图:</p></blockquote> <ul><li><ol><li>链表是以节点的方式来存储,是链式存储</li></ol></li> <li><ol start="2"><li>每个节点包含    data   域，    next   域：指向下一个节点.</li></ol></li> <li><ol start="3"><li>如图：发现链表的各个节点不一定是连续存储.</li></ol></li> <li><ol start="4"><li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li></ol></li></ul> <blockquote><p>单链表(带头结点)   逻辑结构示意图如下</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/2.jpg" alt="带头结点-单链表"></p> <h2 id="_4-2-单链表的应用实例"><a href="#_4-2-单链表的应用实例" class="header-anchor">#</a> 4.2 单链表的应用实例</h2> <div class="language- extra-class"><pre><code>   使用带  head  头的单向链表实现    –水浒英雄排行榜管理完成对英雄人物的增删改查操作 
注:   删除和修改,查找 可以考虑学员独立完成，也可带学员完成 
1) 第一种方法在添加英雄时，直接添加到链表的尾部 
</code></pre></div><blockquote><p>思路分析示意图:
<img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/3.jpg" alt="单链表创建示意图"></p></blockquote> <div class="language- extra-class"><pre><code>2) 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 
</code></pre></div><blockquote><p>思路的分析示意图:
<img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/4.jpg" alt="添加节点"></p></blockquote> <div class="language- extra-class"><pre><code>3) 修改节点功能 
思路：
 (1)   先找到该节点，通过遍历，
 (2) temp.name  = newHeroNode.name  ;  temp.nickname=  newHeroNode.nickname 
4) 删除节点 
</code></pre></div><blockquote><p>思路分析的示意图:</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/5.jpg" alt="删除节点"></p> <div class="language- extra-class"><pre><code>5) 完成的代码演示: 

package com.lyg.four;
import java.util.Stack;

/**
 * @program: DataStructure
 * @description: 单向链表
 * @author: LvYangai
 * @create: 2020-06-21 14:47
 * @e-mail: 1076977275@qq.com
 **/
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        //测试
        //先创建节点
        HeroNode heroNode1 = new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);
        HeroNode heroNode2 = new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);
        HeroNode heroNode3 = new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;);
        HeroNode heroNode4 = new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);
        //创建要给链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        //加入
        singleLinkedList.addByOrder(heroNode3);
        singleLinkedList.addByOrder(heroNode2);
        singleLinkedList.addByOrder(heroNode1);
        singleLinkedList.addByOrder(heroNode4);
        singleLinkedList.addByOrder(heroNode2);
        singleLinkedList.list();

        System.out.println(&quot;修改后&quot;);
        //修改
        singleLinkedList.update(new HeroNode(4,&quot;阿林&quot;,&quot;豹子头&quot;));
        singleLinkedList.list();

        //删除
        System.out.println(&quot;删除后&quot;);

        singleLinkedList.del(4);
        singleLinkedList.list();
    }


}
//定义SingleLinkedList 管理我们但英雄
class SingleLinkedList{
    //初始化一个头节点，头节点不能动
    private HeroNode head = new HeroNode(0,&quot;&quot;,&quot;&quot;);
    //添加节点到单向链表
    //思路，当不考虑编号顺序式
    //1.找到当前链表到最后节点
    //2.将最后这个节点的next 指向 新的节点
    public void add(HeroNode heroNode){
        //判断节点是否为空
        //因为节点不能动，因此我们需要一个辅助遍历temp
        HeroNode temp = head;
        while(temp.next != null){
            temp = temp.next;
        }
        temp.next = heroNode;
    }
    //遍历显示节点
    public void list(){
        //判断链表是否为空
        if (head.next == null){
            System.out.println(&quot;链表为空&quot;);
            return;
        }
        //辅助节点遍历
        HeroNode temp = head.next;
        while (temp != null){
            System.out.println(temp);
            temp = temp.next;
        }
    }
    //第二种添加方式在添加英雄时，根据排名将英雄插入到指定位置
    //如果有这个排名，则添加失败，并给出提示
    public void addByOrder(HeroNode heroNode){
        //因为头节点不能动  所以需要辅助节点
        //因为单链表找的temp是位于添加位置的前一个节点，否则插入不了
        HeroNode temp = head;
        while (temp.next != null){
            if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
                System.out.printf(&quot;准备插入的英雄编号%d已经存在了\n&quot;,heroNode.no);
               return;
            }else if (temp.next.no &gt; heroNode.no){
                break;
            }
            temp = temp.next;
        }
        //插入到链表
        heroNode.next = temp.next;
        temp.next = heroNode;

    }
    //修改节点信息，根据no 编号来修改，即no编号不能改
    //说明
    //1.根据newHeroNode的no来修改
    public void update(HeroNode newHeroNode){
        //判断是否为空
        if (head.next == null){
            System.out.println(&quot;链表为空&quot;);
            return;
        }
        //找到需要修改的节点，根据NO编号
        //定义一个辅助变量
        HeroNode temp = head.next;
        boolean flag = false; //表示是否找到该节点
        while(true) {
            if (temp == null) {
                break; //已经遍历完链表
            }
            if(temp.no == newHeroNode.no) {
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag 判断是否找到要修改的节点
        if(flag) {
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        } else { //没有找到
            System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);
        }
    }
    //删除节点
    //
    public void del(int no){
        HeroNode temp = head;
        while ( temp.next != null &amp;&amp; temp.next.no != no){
            temp = temp.next;
        }
        if (temp.next.no == no){
            temp.next = temp.next.next;
        }else {
            System.out.println(&quot;要删除的节点没有找到&quot;);
        }
    }


}

//定义HeroNode ，每个HeroNode 对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    public HeroNode next;



    //构造器
    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return &quot;HeroNode{&quot; +
                &quot;no=&quot; + no +
                &quot;, name='&quot; + name + '\'' +
                &quot;, nickname='&quot; + nickname + '\'' +
                '}';
    }
}
</code></pre></div><h2 id="_4-3-单链表面试题-新浪、百度、腾讯"><a href="#_4-3-单链表面试题-新浪、百度、腾讯" class="header-anchor">#</a> 4.3 单链表面试题(新浪、百度、腾讯)</h2> <div class="language- extra-class"><pre><code>单链表的常见面试题有如下:
</code></pre></div><h3 id="_1-求单链表中有效节点的个数"><a href="#_1-求单链表中有效节点的个数" class="header-anchor">#</a> 1) 求单链表中有效节点的个数</h3> <div class="language- extra-class"><pre><code>代码如下：


	//方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)
	/**
	 * 
	 * @param head 链表的头节点
	 * @return 返回的就是有效节点的个数
	 */
	public static int getLength(HeroNode head) {
		if(head.next == null) { //空链表
			return 0;
		}
		int length = 0;
		//定义一个辅助的变量, 这里我们没有统计头节点
		HeroNode cur = head.next;
		while(cur != null) {
			length++;
			cur = cur.next; //遍历
		}
		return length;
	}
</code></pre></div><h3 id="_2-查找单链表中的倒数第-k-个结点-【新浪面试题】"><a href="#_2-查找单链表中的倒数第-k-个结点-【新浪面试题】" class="header-anchor">#</a> 2) 查找单链表中的倒数第 k 个结点 【新浪面试题】</h3> <blockquote><p>代码演示</p></blockquote> <div class="language- extra-class"><pre><code>//查找单链表中的倒数第k个结点 【新浪面试题】
//思路
//1. 编写一个方法，接收head节点，同时接收一个index 
//2. index 表示是倒数第index个节点
//3. 先把链表从头到尾遍历，得到链表的总的长度 getLength
//4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到
//5. 如果找到了，则返回该节点，否则返回nulll
public static HeroNode findLastIndexNode(HeroNode head, int index) {
	//判断如果链表为空，返回null
	if(head.next == null) {
		return null;//没有找到
	}
	//第一个遍历得到链表的长度(节点个数)
	int size = getLength(head);
	//第二次遍历  size-index 位置，就是我们倒数的第K个节点
	//先做一个index的校验
	if(index &lt;=0 || index &gt; size) {
		return null; 
	}
	//定义给辅助变量， for 循环定位到倒数的index
	HeroNode cur = head.next; //3 // 3 - 1 = 2
	for(int i =0; i&lt; size - index; i++) {
		cur = cur.next;
	}
	return cur;
	
}
</code></pre></div><h3 id="_3-单链表的反转【腾讯面试题，有点难度】"><a href="#_3-单链表的反转【腾讯面试题，有点难度】" class="header-anchor">#</a> 3) 单链表的反转【腾讯面试题，有点难度】</h3> <blockquote><p>思路分解图</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/6.jpg" alt="腾讯面试题"></p> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/7.jpg" alt="腾讯面试题思路"></p> <blockquote><p>代码实现
//将单链表反转
public static void reversetList(HeroNode head) {
//如果当前链表为空，或者只有一个节点，无需反转，直接返回
if(head.next == null || head.next.next == null) {
return ;
}</p></blockquote> <div class="language- extra-class"><pre><code>	//定义一个辅助的指针(变量)，帮助我们遍历原来的链表
	HeroNode cur = head.next;
	HeroNode next = null;// 指向当前节点[cur]的下一个节点
	HeroNode reverseHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);
	//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端
	//动脑筋
	while(cur != null) { 
		next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用
		cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端
		reverseHead.next = cur; //将cur 连接到新的链表上
		cur = next;//让cur后移
	}
	//将head.next 指向 reverseHead.next , 实现单链表的反转
	head.next = reverseHead.next;
}
</code></pre></div><blockquote><p>代码运行图解（自己手动画图）</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/8.jpg" alt="手动图解"></p> <h3 id="_4-从尾到头打印单链表-【百度，要求方式-1：反向遍历-。-方式-2：stack-栈】"><a href="#_4-从尾到头打印单链表-【百度，要求方式-1：反向遍历-。-方式-2：stack-栈】" class="header-anchor">#</a> 4) 从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】</h3> <blockquote><p>思路分析图解</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/9.jpg" alt="栈"></p> <blockquote><p>代码演示</p></blockquote> <div class="language- extra-class"><pre><code>//方式2
//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果
public static void reversePrint(HeroNode head) {
	if(head.next == null) {
		return;//空链表，不能打印
	}
	//创建要给一个栈，将各个节点压入栈
	Stack&lt;HeroNode&gt; stack = new Stack&lt;HeroNode&gt;();
	HeroNode cur = head.next;
	//将链表的所有节点压入栈
	while(cur != null) {
		stack.push(cur);
		cur = cur.next; //cur后移，这样就可以压入下一个节点
	}
	//将栈中的节点进行打印,pop 出栈
	while (stack.size() &gt; 0) {
		System.out.println(stack.pop()); //stack的特点是先进后出
	}
}
</code></pre></div><h2 id="_4-双向链表应用实例"><a href="#_4-双向链表应用实例" class="header-anchor">#</a> 4. 双向链表应用实例</h2> <h3 id="_4-1双向链表的操作分析和实现"><a href="#_4-1双向链表的操作分析和实现" class="header-anchor">#</a> 4.1双向链表的操作分析和实现</h3> <div class="language- extra-class"><pre><code>使用带 head 头的双向链表实现 –水浒英雄排行榜
</code></pre></div><blockquote><p>管理单向链表的缺点分析:
1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除
时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). 3) 分析了双向链表如何完成遍历，添加，修改和删除的思路
点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/10.jpg" alt="双向链表"></p> <div class="language- extra-class"><pre><code>对上图的说明:
  分析 双向链表的遍历，添加，修改，删除的操作思路=》代码实现
	1) 遍历 方和 单链表一样，只是可以向前，也可以向后查找
	2) 添加 (默认添加到双向链表的最后)
(1) 先找到双向链表的最后这个节点
(2) temp.next = newHeroNde
(3) newHeroNde.pre = temp;

	3) 修改 思路和 原来的单向链表一样. 
	4) 删除
3) 修改 
(1) 因为是双向链表，因此，我们可以实现自我删除某个节点
(2) 直接找到要删除的这个节点，比如 temp
(3) temp.re.nxt =emp.next
(4) temp.next.pre = temp.re;
</code></pre></div><blockquote><p>双向链表的代码实现</p></blockquote> <div class="language- extra-class"><pre><code>package com.lyg.four;

/**
 * @program: DataStructure
 * @description: 双向链表
 * @author: LvYangai
 * @create: 2020-06-22 13:03
 * @e-mail: 1076977275@qq.com
 **/
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        // 测试
        System.out.println(&quot;双向链表的测试&quot;);
        // 先创建节点
        HeroNode2 hero1 = new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);
        HeroNode2 hero2 = new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
        HeroNode2 hero3 = new HeroNode2(3, &quot;吴用&quot;, &quot;智多星&quot;);
        HeroNode2 hero4 = new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);
        // 创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(hero1);
        doubleLinkedList.add(hero2);
        doubleLinkedList.add(hero3);
        doubleLinkedList.add(hero4);

        doubleLinkedList.list();

        // 修改
        HeroNode2 newHeroNode = new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);
        doubleLinkedList.update(newHeroNode);
        System.out.println(&quot;修改后的链表情况&quot;);
        doubleLinkedList.list();

        // 删除
        doubleLinkedList.del(4);
        System.out.println(&quot;删除后的链表情况~~&quot;);
        doubleLinkedList.list();
    }
}
class DoubleLinkedList{
    //初始化一个头节点，头节点不能动
    private HeroNode2 head = new HeroNode2(0,&quot;&quot;,&quot;&quot;);



    //遍历显示节点
    public void list(){
        //判断链表是否为空
        if (head.next == null){
            System.out.println(&quot;链表为空&quot;);
            return;
        }
        //辅助节点遍历
        HeroNode2 temp = head.next;
        while (temp != null){
            System.out.println(temp);
            temp = temp.next;
        }
    }
    //添加
    public void add(HeroNode2 heroNode){
        //判断节点是否为空
        //因为节点不能动，因此我们需要一个辅助遍历temp
        HeroNode2 temp = head;
        while(temp.next != null){
            temp = temp.next;
        }
        temp.next = heroNode;
        heroNode.pre = temp;
    }
    //修改
    public void update(HeroNode2 newHeroNode){
        //判断是否为空
        if (head.next == null){
            System.out.println(&quot;链表为空&quot;);
            return;
        }
        //找到需要修改的节点，根据NO编号
        //定义一个辅助变量
        HeroNode2 temp = head.next;
        boolean flag = false; //表示是否找到该节点
        while(true) {
            if (temp == null) {
                break; //已经遍历完链表
            }
            if(temp.no == newHeroNode.no) {
                //找到
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag 判断是否找到要修改的节点
        if(flag) {
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        } else { //没有找到
            System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);
        }
    }
    //删除节点
    public void del(int no){
        if(head.next == null){
            System.out.println(&quot;链表为空，不能删除&quot;);
            return;
        }
        HeroNode2 temp = head.next;
        boolean flag = false;
        while(true){
            if (temp == null){
                break;
            }
            if (temp.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){
            temp.pre.next = temp.next;
            if (temp.next != null){
                temp.next.pre = temp.pre;
            }
        }else {
            System.out.println(&quot;要删除的节点&quot;+no+&quot;不存在&quot;);
        }

    }
}
//定义HeroNode2 （双向链表）,每个HeroNode 对象就是一个节点
class HeroNode2{
    public int no;
    public String name;
    public String nickName;
    public HeroNode2 next;//后一个节点
    public HeroNode2 pre;//前一个节点

    //构造器
    public HeroNode2(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }
    //为了显示方法  我们重写toString

    @Override
    public String toString() {
        return &quot;HeroNode2{&quot; +
                &quot;no=&quot; + no +
                &quot;, name='&quot; + name + '\'' +
                &quot;, nickName='&quot; + nickName + '\'' +
                '}';
    }
}
</code></pre></div><h3 id="_4-2课堂作业和思路提示"><a href="#_4-2课堂作业和思路提示" class="header-anchor">#</a> 4.2课堂作业和思路提示</h3> <div class="language- extra-class"><pre><code>双向链表的第二种添加方式,按照编号顺序 [示意图]按照单链表的顺序添加，稍作修改即可.
</code></pre></div><h2 id="_4-5-单向环形链表应用场景"><a href="#_4-5-单向环形链表应用场景" class="header-anchor">#</a> 4.5 单向环形链表应用场景</h2> <div class="language- extra-class"><pre><code>Josephu(约瑟夫、约瑟夫环) 问题
   Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数
到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由
此产生一个出队编号的序列。
提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结
点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直
到最后一个结点从链表中删除算法结束。
</code></pre></div><p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/11.jpg" alt="单向环形链表"></p> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/12.jpg" alt="单向环形链表2"></p> <h2 id="_4-7-josephu-问题"><a href="#_4-7-josephu-问题" class="header-anchor">#</a> 4.7 Josephu 问题</h2> <blockquote><p>约瑟夫问题的示意图</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/13.jpg" alt="Josephu环"></p> <blockquote><p>Josephu 问题</p></blockquote> <div class="language- extra-class"><pre><code>   Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到
m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此
产生一个出队编号的序列。
</code></pre></div><blockquote><p>提示</p></blockquote> <div class="language- extra-class"><pre><code>   用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开
始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个
结点从链表中删除算法结束。
</code></pre></div><blockquote><p>约瑟夫问题-创建环形链表的思路图解</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/14.jpg" alt="创建环形链表的思路图解"></p> <blockquote><p>约瑟夫问题-小孩出圈的思路分析图</p></blockquote> <p><img src="/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/15.jpg" alt="小孩出圈的思路分析图"></p> <h2 id="_4-8-josephu-问题的代码实现"><a href="#_4-8-josephu-问题的代码实现" class="header-anchor">#</a> 4.8 Josephu 问题的代码实现</h2> <div class="language- extra-class"><pre><code>package com.lyg.four;

/**
 * @program: DataStructure
 * @description: 约瑟夫环形链表
 * @author: LvYangai
 * @create: 2020-06-22 14:19
 * @e-mail: 1076977275@qq.com
 **/
public class Josepfu {
    public static void main(String[] args) {
        CircleSingleLinkedList linkeList = new CircleSingleLinkedList();
        linkeList.addBoy(5);
        linkeList.showBoy();
        linkeList.countBoy(1,2,5);
    }
}

// 创建一个环形的单向链表
class CircleSingleLinkedList {
    // 创建一个first节点,当前没有编号
    private Boy first = null;

    // 添加小孩节点，构建成一个环形的链表
    public void addBoy(int nums) {
        // nums 做一个数据校验
        if (nums &lt; 1) {
            System.out.println(&quot;nums的值不正确&quot;);
            return;
        }
        Boy curBoy = null; // 辅助指针，帮助构建环形链表
        // 使用for来创建我们的环形链表
        for (int i = 1; i &lt;= nums; i++) {
            // 根据编号，创建小孩节点
            Boy boy = new Boy(i);
            // 如果是第一个小孩
            if (i == 1) {
                first = boy;
                first.setNext(first); // 构成环
                curBoy = first; // 让curBoy指向第一个小孩
            } else {
                curBoy.setNext(boy);//
                boy.setNext(first);//
                curBoy = boy;
            }
        }
    }

    // 遍历当前的环形链表
    public void showBoy() {
        // 判断链表是否为空
        if (first == null) {
            System.out.println(&quot;没有任何小孩~~&quot;);
            return;
        }
        // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历
        Boy curBoy = first;
        while (true) {
            System.out.printf(&quot;小孩的编号 %d \n&quot;, curBoy.getNo());
            if (curBoy.getNext() == first) {// 说明已经遍历完毕
                break;
            }
            curBoy = curBoy.getNext(); // curBoy后移
        }
    }

    // 根据用户的输入，计算出小孩出圈的顺序
    /**
     *
     * @param startNo
     *            表示从第几个小孩开始数数
     * @param countNum
     *            表示数几下
     * @param nums
     *            表示最初有多少小孩在圈中
     */
    public void countBoy(int startNo, int countNum, int nums) {
        // 先对数据进行校验
        if (first == null || startNo &lt; 1 || startNo &gt; nums) {
            System.out.println(&quot;参数输入有误， 请重新输入&quot;);
            return;
        }
        // 创建要给辅助指针,帮助完成小孩出圈
        Boy helper = first;
        // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点
        while (true) {
            if (helper.getNext() == first) { // 说明helper指向最后小孩节点
                break;
            }
            helper = helper.getNext();
        }
        //小孩报数前，先让 first 和  helper 移动 k - 1次
        for(int j = 0; j &lt; startNo - 1; j++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈
        //这里是一个循环操作，知道圈中只有一个节点
        while(true) {
            if(helper == first) { //说明圈中只有一个节点
                break;
            }
            //让 first 和 helper 指针同时 的移动 countNum - 1
            for(int j = 0; j &lt; countNum - 1; j++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            //这时first指向的节点，就是要出圈的小孩节点
            System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());
            //这时将first指向的小孩节点出圈
            first = first.getNext();
            helper.setNext(first); //

        }
        System.out.printf(&quot;最后留在圈中的小孩编号%d \n&quot;, first.getNo());

    }
}

// 创建一个Boy类，表示一个节点
class Boy {
    private int no;// 编号
    private Boy next; // 指向下一个节点,默认null

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/JAVA/数据结构与算法/第三章.html" class="prev">
        三、稀疏数组和队列
      </a></span> <span class="next"><a href="/pages/JAVA/数据结构与算法/第五章.html">
        五、栈
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b653f105.js" defer></script><script src="/assets/js/2.99d1a617.js" defer></script><script src="/assets/js/22.f98eeba2.js" defer></script>
  </body>
</html>
