(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{344:function(t,n,a){"use strict";a.r(n);var e=a(33),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"对象-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象-函数"}},[t._v("#")]),t._v(" 对象 函数")]),t._v(" "),a("h2",{attrs:{id:"_1-对象（object）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-对象（object）"}},[t._v("#")]),t._v(" 1.对象（Object）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('- 对象是JS中的引用数据类型\n- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性\n- 使用typeof检查一个对象时，会返回object\n- 创建对象\n\t- 方式一：\n\t\t- var obj = new Object();\n\t- 方式二：\n\t\t- var obj = {};\n\t\t\n- 向对象中添加属性\n\t- 语法：\n\t\t对象.属性名 = 属性值;\n\t\t对象["属性名"] = 属性值;\n\t\t\n\t\t- 对象的属性名没有任何要求，不需要遵守标识符的规范，\n\t\t\t但是在开发中，尽量按照标识符的要求去写。\n\t\t- 属性值也可以任意的数据类型。\n\n- 读取对象中的属性\n\t- 语法：\n\t\t对象.属性名\n\t\t对象["属性名"]\n\t- 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined\n\t\n- 删除对象中的属性\n\t- 语法：\n\t\tdelete 对象.属性名\n\t\tdelete 对象["属性名"]\n\t\t\n- 使用in检查对象中是否含有指定属性\n\t- 语法："属性名" in 对象\n\t\t- 如果在对象中含有该属性，则返回true\n\t\t\t如果没有则返回false\n\t\t\t\n- 使用对象字面量，在创建对象时直接向对象中添加属性\n\t语法：\n\t\tvar obj = {\n\t\t\t\t\t\t属性名:属性值,\n\t\t\t\t\t\t属性名:属性值,\n\t\t\t\t\t\t属性名:属性值,\n\t\t\t\t\t\t属性名:属性值\n\t\t\t\t}\n\t\t\t\t\n- 基本数据类型和引用数据类型\n\t- 基本数据类型\n\t\tString Number Boolean Null Undefined\n\t- 引用数据类型\n\t\tObject\n\t- 基本数据类型的数据，变量是直接保存的它的值。\n\t\t变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。\n\t- 引用数据类型的数据，变量是保存的对象的引用（内存地址）。\n\t\t如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。\n\t- 比较两个变量时，对于基本数据类型，比较的就是值，\n\t\t对于引用数据类型比较的是地址，地址相同才相同\n')])])]),a("h2",{attrs:{id:"_2-函数（function）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数（function）"}},[t._v("#")]),t._v(" 2.函数（Function）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("- 函数也是一个对象，也具有普通对象的功能\n- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码\n- 使用typeof检查一个函数时会返回function\n- 创建函数\n\t- 函数声明\n\t\tfunction 函数名([形参1,形参2...形参N]){\n\t\t\t语句...\n\t\t}\n\t\n\t- 函数表达式\n\t\tvar 函数名 = function([形参1,形参2...形参N]){\n\t\t\t语句...\n\t\t};\n\t\t\n- 调用函数\n\t- 语法：函数对象([实参1,实参2...实参N]);\n\t\tfun() sum() alert() Number() parseInt()\n\t- 当我们调用函数时，函数中封装的代码会按照编写的顺序执行\n\n- 形参和实参\n\t- 形参：形式参数\n\t\t- 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开\n\t\t\t定义形参就相当于在函数内声明了对应的变量但是并不赋值，\n\t\t\t形参会在调用时才赋值。\n\t\t\t\n\t- 实参：实际参数\n\t\t- 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,\n\t\t\t调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。\n\t\t\t如果实参的数量大于形参，多余实参将不会赋值，\n\t\t\t如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined\n")])])]),a("h2",{attrs:{id:"函数作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[t._v("#")]),t._v(" 函数作用域")]),t._v(" "),a("h3",{attrs:{id:"说出以下代码的执行结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说出以下代码的执行结果"}},[t._v("#")]),t._v(" 说出以下代码的执行结果")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("=========================================\n\nvar a = 123;\nfunction fun(){\n\talert(a);\n}\nfun();\n\n=========================================\n\nvar a = 123;\nfunction fun(){\n\talert(a);\n\tvar a = 456;\n}\nfun();\nalert(a);\n\n=========================================\n\nvar a = 123;\nfunction fun(){\n\talert(a);\n\ta = 456;\n}\nfun();\nalert(a);\n\n=========================================\n\nvar a = 123;\nfunction fun(a){\n\talert(a);\n\ta = 456;\n}\nfun();\nalert(a);\n\n=========================================\n\nvar a = 123;\nfunction fun(a){\n\talert(a);\n\ta = 456;\n}\nfun(123);\nalert(a);\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);