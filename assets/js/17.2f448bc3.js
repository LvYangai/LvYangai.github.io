(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{337:function(t,n,e){"use strict";e.r(n);var i=e(33),a=Object(i.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"第-9-章-哈希表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第-9-章-哈希表"}},[t._v("#")]),t._v(" 第 9 章 哈希表")]),t._v(" "),e("h2",{attrs:{id:"_9-1-哈希表-散列-gogle-上机题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-哈希表-散列-gogle-上机题"}},[t._v("#")]),t._v(" 9.1 哈希表(散列)-Gogle 上机题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(" 1) 看一个实际需求，gogle 公司的一个上机题:\n 2) 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址.),当输入该员工的 id 时,要求查\n找到该员工的 所有信息. \n找到该员工的 所有信息. 3) 要求: 不使用数据库,尽量节省内存,速度越快越好=>哈希表(散列)\n")])])]),e("h2",{attrs:{id:"_9-2-哈希表的基本介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-哈希表的基本介绍"}},[t._v("#")]),t._v(" 9.2 哈希表的基本介绍")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，\n它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的\n数组叫做散列表。\n")])])]),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B9%9D%E7%AB%A0_files/1.jpg",alt:"散列表"}}),t._v(" "),e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B9%9D%E7%AB%A0_files/2.jpg",alt:"链表"}})]),t._v(" "),e("h2",{attrs:{id:"_9-3-gogle-公司的一个上机题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-gogle-公司的一个上机题"}},[t._v("#")]),t._v(" 9.3 gogle 公司的一个上机题:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址.),当输入该员工的 id 时,\n要求查找到该员工的所有信息\n要求:\n 1) 不使用数据库,速度越快越好=>哈希表(散列)\n 2) 添加时，保证按照 id 从低到高插入 [课后思考：如果 id 不是从低到高插入，但要求各条链表仍是从低到\n\t高，怎么解决?]\n 3) 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]\n 4) 思路分析并画出示意图\n")])])]),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B9%9D%E7%AB%A0_files/3.jpg",alt:"哈希表雇员信息"}}),t._v("\n代码：\npublic class HashTabDemo {")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('\tpublic static void main(String[] args) {\n\t\t\n\t\t//创建哈希表\n\t\tHashTab hashTab = new HashTab(7);\n\t\t\n\t\t//写一个简单的菜单\n\t\tString key = "";\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tSystem.out.println("add:  添加雇员");\n\t\t\tSystem.out.println("list: 显示雇员");\n\t\t\tSystem.out.println("find: 查找雇员");\n\t\t\tSystem.out.println("exit: 退出系统");\n\t\t\t\n\t\t\tkey = scanner.next();\n\t\t\tswitch (key) {\n\t\t\tcase "add":\n\t\t\t\tSystem.out.println("输入id");\n\t\t\t\tint id = scanner.nextInt();\n\t\t\t\tSystem.out.println("输入名字");\n\t\t\t\tString name = scanner.next();\n\t\t\t\t//创建 雇员\n\t\t\t\tEmp emp = new Emp(id, name);\n\t\t\t\thashTab.add(emp);\n\t\t\t\tbreak;\n\t\t\tcase "list":\n\t\t\t\thashTab.list();\n\t\t\t\tbreak;\n\t\t\tcase "find":\n\t\t\t\tSystem.out.println("请输入要查找的id");\n\t\t\t\tid = scanner.nextInt();\n\t\t\t\thashTab.findEmpById(id);\n\t\t\t\tbreak;\n\t\t\tcase "exit":\n\t\t\t\tscanner.close();\n\t\t\t\tSystem.exit(0);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n\n//创建HashTab 管理多条链表\nclass HashTab {\n\tprivate EmpLinkedList[] empLinkedListArray;\n\tprivate int size; //表示有多少条链表\n\t\n\t//构造器\n\tpublic HashTab(int size) {\n\t\tthis.size = size;\n\t\t//初始化empLinkedListArray\n\t\tempLinkedListArray = new EmpLinkedList[size];\n\t\t//？留一个坑, 这时不要分别初始化每个链表\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tempLinkedListArray[i] = new EmpLinkedList();\n\t\t}\n\t}\n\t\n\t//添加雇员\n\tpublic void add(Emp emp) {\n\t\t//根据员工的id ,得到该员工应当添加到哪条链表\n\t\tint empLinkedListNO = hashFun(emp.id);\n\t\t//将emp 添加到对应的链表中\n\t\tempLinkedListArray[empLinkedListNO].add(emp);\n\t\t\n\t}\n\t//遍历所有的链表,遍历hashtab\n\tpublic void list() {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tempLinkedListArray[i].list(i);\n\t\t}\n\t}\n\t\n\t//根据输入的id,查找雇员\n\tpublic void findEmpById(int id) {\n\t\t//使用散列函数确定到哪条链表查找\n\t\tint empLinkedListNO = hashFun(id);\n\t\tEmp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);\n\t\tif(emp != null) {//找到\n\t\t\tSystem.out.printf("在第%d条链表中找到 雇员 id = %d\\n", (empLinkedListNO + 1), id);\n\t\t}else{\n\t\t\tSystem.out.println("在哈希表中，没有找到该雇员~");\n\t\t}\n\t}\n\t\n\t//编写散列函数, 使用一个简单取模法\n\tpublic int hashFun(int id) {\n\t\treturn id % size;\n\t}\n\t\n\t\n}\n\n//表示一个雇员\nclass Emp {\n\tpublic int id;\n\tpublic String name;\n\tpublic Emp next; //next 默认为 null\n\tpublic Emp(int id, String name) {\n\t\tsuper();\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n}\n\n//创建EmpLinkedList ,表示链表\nclass EmpLinkedList {\n\t//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp\n\tprivate Emp head; //默认null\n\t\n\t//添加雇员到链表\n\t//说明\n\t//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大\n\t//   因此我们将该雇员直接加入到本链表的最后即可\n\tpublic void add(Emp emp) {\n\t\t//如果是添加第一个雇员\n\t\tif(head == null) {\n\t\t\thead = emp;\n\t\t\treturn;\n\t\t}\n\t\t//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后\n\t\tEmp curEmp = head;\n\t\twhile(true) {\n\t\t\tif(curEmp.next == null) {//说明到链表最后\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurEmp = curEmp.next; //后移\n\t\t}\n\t\t//退出时直接将emp 加入链表\n\t\tcurEmp.next = emp;\n\t}\n\t\n\t//遍历链表的雇员信息\n\tpublic void list(int no) {\n\t\tif(head == null) { //说明链表为空\n\t\t\tSystem.out.println("第 "+(no+1)+" 链表为空");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print("第 "+(no+1)+" 链表的信息为");\n\t\tEmp curEmp = head; //辅助指针\n\t\twhile(true) {\n\t\t\tSystem.out.printf(" => id=%d name=%s\\t", curEmp.id, curEmp.name);\n\t\t\tif(curEmp.next == null) {//说明curEmp已经是最后结点\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurEmp = curEmp.next; //后移，遍历\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t//根据id查找雇员\n\t//如果查找到，就返回Emp, 如果没有找到，就返回null\n\tpublic Emp findEmpById(int id) {\n\t\t//判断链表是否为空\n\t\tif(head == null) {\n\t\t\tSystem.out.println("链表为空");\n\t\t\treturn null;\n\t\t}\n\t\t//辅助指针\n\t\tEmp curEmp = head;\n\t\twhile(true) {\n\t\t\tif(curEmp.id == id) {//找到\n\t\t\t\tbreak;//这时curEmp就指向要查找的雇员\n\t\t\t}\n\t\t\t//退出\n\t\t\tif(curEmp.next == null) {//说明遍历当前链表没有找到该雇员\n\t\t\t\tcurEmp = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurEmp = curEmp.next;//以后\n\t\t}\n\t\t\n\t\treturn curEmp;\n\t}\n\t\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);