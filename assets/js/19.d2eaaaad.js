(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{339:function(t,n,s){"use strict";s.r(n);var e=s(33),i=Object(e.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),s("h2",{attrs:{id:"_5-1-栈的一个实际需求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-栈的一个实际需求"}},[t._v("#")]),t._v(" 5.1 栈的一个实际需求")]),t._v(" "),s("blockquote",[s("p",[t._v("请输入一个表达式")])]),t._v(" "),s("blockquote",[s("p",[t._v("计算式:[7*2-5+1-5+3-] 点击计算【如下图】")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/1.jpg",alt:"表达式"}})]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("   请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算,因为我们看这个算式 7 * 2 * 2 - 5,\n但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-> 栈\n")])])]),s("h2",{attrs:{id:"_5-2-栈的介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-栈的介绍"}},[t._v("#")]),t._v(" 5.2 栈的介绍")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("1)栈的英文为(stack) \n2)栈是一个先入后出(FILO-First In  Last Out)的有序列表。 \n3)栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。\n  允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 \n4)根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，\n  最后放入的元 素最先删除，最先放入的元素最后删除 \n5)图解方式说明出栈(pop)和入栈(push)的概念\n")])])]),s("p",[s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/2.jpg",alt:"出栈和入栈"}})]),t._v(" "),s("h2",{attrs:{id:"_5-3-栈的应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-栈的应用场景"}},[t._v("#")]),t._v(" 5.3 栈的应用场景")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("1)子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。 \n2)处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。 \n3)表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 \n4)二叉树的遍历。 \n5)图形的深度优先(depth  一  first)搜索法。\n")])])]),s("h2",{attrs:{id:"_5-4栈的快速入门"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-4栈的快速入门"}},[t._v("#")]),t._v(" 5.4栈的快速入门")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("1)用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， \n  下面我们就用数组模拟栈的出栈，入栈等操作。 \n2)实现思路分析,并画出示意图\n")])])]),s("p",[s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/3.jpg",alt:"存储数据内容"}})]),t._v(" "),s("blockquote",[s("p",[t._v("代码实现")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('package com.lyg.five;\nimport java.util.Scanner;\n\n/**\n * @program: DataStructure\n * @description: 栈\n * @author: LvYangai\n * @create: 2020-06-23 15:12\n * @e-mail: 1076977275@qq.com\n **/\npublic class ArrayStackDemo {\n    public static void main(String[] args) {\n        //测试一下ArrayStack是否正确\n        //先创建一个ArrayStack对象-》表示栈\n        ArrayStack stack = new ArrayStack(4);\n        String key = "";\n        boolean loop = true;\n        Scanner scanner = new Scanner(System.in);\n        while (loop){\n            System.out.println("show:表示显示栈");\n            System.out.println("exit:退出程序");\n            System.out.println("push:添加数据（入栈）");\n            System.out.println("pop:取出数据（出栈）");\n            key = scanner.next();\n            switch (key){\n                case "show":\n                    stack.list();\n                    break;\n                case "push":\n                    System.out.println("请输入一个数");\n                    int value = scanner.nextInt();\n                    stack.push(value);\n                    break;\n                case "pop":\n                    try{\n                        int res = stack.pop();\n                        System.out.println("出栈："+res);\n                    }catch (Exception e){\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case "exit":\n                    scanner.close();\n                    loop = false;\n                    break;\n                default:break;\n            }\n        }\n        System.out.println("程序退出");\n    }\n}\nclass ArrayStack{\n    private int maxSize;\n    private int[] stack;\n    private int top = -1;\n\n    //构造器\n    public ArrayStack(int maxSize){\n        this.maxSize = maxSize;\n        stack = new int[this.maxSize];\n    }\n    //栈满\n    public boolean isFull(){\n        return top == maxSize - 1;\n    }\n    //栈空\n    public boolean isEmpty(){\n        return top == -1;\n    }\n\n    //入栈-push\n    public void push(int value){\n        //先判断栈是否满\n        if (isFull()){\n            System.out.println("栈满");\n            return;\n        }\n        stack[++top] = value;\n    }\n    //出栈-pop 栈顶数据返回\n    public int pop(){\n        //判断栈是否为空\n        if (isEmpty()){\n            //抛出异常\n            throw new RuntimeException("栈空,没有数据");\n        }\n        return stack[top--];\n    }\n    //遍历栈\n    public void list(){\n        if (isEmpty()){\n            System.out.println("栈空，没有数据");\n            return;\n        }\n        for(int i = top; i >= 0; i--){\n            System.out.println("stack["+i+"] = "+stack[i]);\n        }\n    }\n\n}\n\n4)   关于栈的一个小练习 \n   课堂练习，将老师写的程序改成使用链表来模拟栈\n')])])]),s("h2",{attrs:{id:"_5-5-栈实现综合计算器-中缀表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-栈实现综合计算器-中缀表达式"}},[t._v("#")]),t._v(" 5.5        栈实现综合计算器(中缀表达式)")]),t._v(" "),s("blockquote",[s("p",[t._v("使用栈来实现综合计算器\n"),s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/4.jpg",alt:"中缀表达式"}}),t._v("\n思路分解（图解）")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/5.jpg",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("代码实现[1.先实现一位数的运算     2.扩展到多位数的运算]")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("//在上一个栈基础上修改\n public static void main(String[] args) {\n        //测试一下ArrayStack是否正确\n        //先创建一个ArrayStack对象-》表示栈\n        String expression = \"30+20*6-2\";\n        ArrayStack2 numStack = new ArrayStack2(10);\n        ArrayStack2 operStack = new ArrayStack2(10);\n        //定义需要的相关变量\n\n        int num1 = 0;\n        int num2 = 0;\n        int oper = 0;\n        int res = 0;\n        String keepNum = \"\";\n        char ch = ' ';//将每次扫描得到的char保存到ch\n        //开始while循环的扫描expression\n        for (int i = 0;i < expression.length(); i++){\n            //依次得到expression 的每一个字符\n            ch = expression.substring(i,i+1).charAt(0);\n            //判断ch是什么\n            if (operStack.isOper(ch)){//如果是运算符\n                //判断当前符号栈是否为空\n                if (!operStack.isEmpty()){\n                    //如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符\n                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){\n                        num1 = numStack.pop();\n                        num2 = numStack.pop();\n                        oper = operStack.pop();\n                        res = numStack.cal(num1,num2,oper);\n                        //把当前结果入栈\n                        numStack.push(res);\n                        //将当前操作符入符号栈\n                        operStack.push(ch);\n                    }else {\n                        //如果当前操作符优先级大于栈中的操作符，直接入符号栈\n                        operStack.push(ch);\n                    }\n                }else {\n                   //如果为空直接入符号栈\n                    operStack.push(ch);//1+3\n                }\n            }else {\n                //发现是一个数时不能直接入栈 比如43\n                //1.当处理多位数时，不能发现是一个数就立即入栈，因为他是多位数\n                //2.在处理数，需要向expression的表达式的index 后再看一位，如果是数就进行扫描，如果是符号才入栈\n                //3.因此我们需要定义一个变量 字符串，用于拼接\n\n                //处理多位数\n                keepNum += ch;\n                if (i == expression.length()-1){\n                    numStack.push(Integer.parseInt(keepNum));\n                }else {\n                    //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈\n                    //注意看后一位，不是i++\n                    if (operStack.isOper(expression.substring(i+1,i+2).charAt(0))){\n                        //如果最后一位是运算符，则入栈keepnum = 1 或者 123\n                        numStack.push(Integer.parseInt(keepNum));\n                        keepNum = \"\";\n                    }\n                }\n\n//                numStack.push(ch - '0');\n            }\n        }\n        //当表达式扫描完毕，就顺序从数栈和符号栈中pop出相应的数和符号,并运行\n        while (true){\n            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字【结果】\n            if (operStack.isEmpty()){\n                break;\n            }\n            num1 = numStack.pop();\n            num2 = numStack.pop();\n            oper = operStack.pop();\n            res = numStack.cal(num1,num2,oper);\n            numStack.push(res);//入栈\n        }\n        //将数栈的最后数，pop出，就是结果。\n        System.out.println(\"表达式 \"+expression+\" = \"+numStack.pop());\n\n    }\n\t\n//在基础栈的上面扩展 实现计算器\nclass ArrayStack2 {\n    private int maxSize;\n    private int[] stack;\n    private int top = -1;\n\n    //构造器\n    public ArrayStack2(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[this.maxSize];\n    }\n\n    //栈满\n    public boolean isFull() {\n        return top == maxSize - 1;\n    }\n\n    //栈空\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    //入栈-push\n    public void push(int value) {\n        //先判断栈是否满\n        if (isFull()) {\n            System.out.println(\"栈满\");\n            return;\n        }\n        stack[++top] = value;\n    }\n\n    //出栈-pop 栈顶数据返回\n    public int pop() {\n        //判断栈是否为空\n        if (isEmpty()) {\n            //抛出异常\n            throw new RuntimeException(\"栈空,没有数据\");\n        }\n        return stack[top--];\n    }\n\n    //遍历栈\n    public void list() {\n        if (isEmpty()) {\n            System.out.println(\"栈空，没有数据\");\n            return;\n        }\n        for (int i = top; i >= 0; i--) {\n            System.out.println(\"stack[\" + i + \"] = \" + stack[i]);\n        }\n\n    }\n\n    //返回运算符的优先级，优先级是程序员来确定的，优先级使用数字表示\n    //数字越大，则优先级越高\n    public int priority(int oper) {\n        if (oper == '*' || oper == '/') {\n            return 1;\n        } else if (oper == '+' || oper == '-') {\n            return 0;\n        } else {\n            return -1;//假定表达式只含有+-*/\n        }\n    }\n\n    //判断是不是一个运算符\n    public boolean isOper(char val) {\n        return val == '+' || val == '-' || val == '*' || val == '/';\n    }\n\n    //计算方法\n    public int cal(int num1, int num2, int oper) {\n        int res = 0;\n        switch (oper) {\n            case '+':\n                res = num1 + num2;\n                break;\n            case '-':\n                res = num2 - num1;\n                break;\n            case '*':\n                res = num1 * num2;\n                break;\n            case '/':\n                res = num2 / num1;\n                break;\n            default:\n                break;\n        }\n        return res;\n    }\n    //增加方法，可以返回当前栈顶的值，但不是出栈\n    public int peek(){\n        return stack[top];\n    }\n\n}\n")])])]),s("blockquote",[s("p",[t._v("课后的练习-给表达式加入小括号")])]),t._v(" "),s("h2",{attrs:{id:"_5-6-逆波兰计算器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-逆波兰计算器"}},[t._v("#")]),t._v(" 5.6 逆波兰计算器")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('我们完成一个逆波兰计算器，要求完成如下任务:\n 1) 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果\n 2) 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。\n 3) 思路分析\n\n例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:\n1．从左至右扫描，将 3 和 4 压入堆栈；\n2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；\n3．将 5 入栈；\n4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；\n5．将 6 入栈；\n6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果\n\n 4) 代码完成\n \nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class PolandNotation {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t//完成将一个中缀表达式转成后缀表达式的功能\n\t\t//说明\n\t\t//1. 1+((2+3)×4)-5 => 转成  1 2 3 + 4 × + 5 –\n\t\t//2. 因为直接对str 进行操作，不方便，因此 先将  "1+((2+3)×4)-5" =》 中缀的表达式对应的List\n\t\t//   即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]\n\t\t//3. 将得到的中缀表达式对应的List => 后缀表达式对应的List\n\t\t//   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]\n\t\t\n\t\tString expression = "1+((2+3)*4)-5";//注意表达式 \n\t\tList<String> infixExpressionList = toInfixExpressionList(expression);\n\t\tSystem.out.println("中缀表达式对应的List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]\n\t\tList<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);\n\t\tSystem.out.println("后缀表达式对应的List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–] \n\t\t\n\t\tSystem.out.printf("expression=%d", calculate(suffixExpreesionList)); // ?\n\t\t\n\t\t\n\t\t\n\t\t/*\n\t\t\n\t\t//先定义给逆波兰表达式\n\t\t//(30+4)×5-6  => 30 4 + 5 × 6 - => 164\n\t\t// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / + \n\t\t//测试 \n\t\t//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开\n\t\t//String suffixExpression = "30 4 + 5 * 6 -";\n\t\tString suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76\n\t\t//思路\n\t\t//1. 先将 "3 4 + 5 × 6 - " => 放到ArrayList中\n\t\t//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算\n\t\t\n\t\tList<String> list = getListString(suffixExpression);\n\t\tSystem.out.println("rpnList=" + list);\n\t\tint res = calculate(list);\n\t\tSystem.out.println("计算的结果是=" + res);\n\t\t\n\t\t*/\n\t}\n\n\n\n\t//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]\n\t//方法：将得到的中缀表达式对应的List => 后缀表达式对应的List\n\tpublic static List<String> parseSuffixExpreesionList(List<String> ls) {\n\t\t//定义两个栈\n\t\tStack<String> s1 = new Stack<String>(); // 符号栈\n\t\t//说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出\n\t\t//因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2\n\t\t//Stack<String> s2 = new Stack<String>(); // 储存中间结果的栈s2\n\t\tList<String> s2 = new ArrayList<String>(); // 储存中间结果的Lists2\n\t\t\n\t\t//遍历ls\n\t\tfor(String item: ls) {\n\t\t\t//如果是一个数，加入s2\n\t\t\tif(item.matches("\\\\d+")) {\n\t\t\t\ts2.add(item);\n\t\t\t} else if (item.equals("(")) {\n\t\t\t\ts1.push(item);\n\t\t\t} else if (item.equals(")")) {\n\t\t\t\t//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃\n\t\t\t\twhile(!s1.peek().equals("(")) {\n\t\t\t\t\ts2.add(s1.pop());\n\t\t\t\t}\n\t\t\t\ts1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号\n\t\t\t} else {\n\t\t\t\t//当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较\n\t\t\t\t//问题：我们缺少一个比较优先级高低的方法\n\t\t\t\twhile(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item) ) {\n\t\t\t\t\ts2.add(s1.pop());\n\t\t\t\t}\n\t\t\t\t//还需要将item压入栈\n\t\t\t\ts1.push(item);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//将s1中剩余的运算符依次弹出并加入s2\n\t\twhile(s1.size() != 0) {\n\t\t\ts2.add(s1.pop());\n\t\t}\n\n\t\treturn s2; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List\n\t\t\n\t}\n\n\t//方法：将 中缀表达式转成对应的List\n\t//  s="1+((2+3)×4)-5";\n\tpublic static List<String> toInfixExpressionList(String s) {\n\t\t//定义一个List,存放中缀表达式 对应的内容\n\t\tList<String> ls = new ArrayList<String>();\n\t\tint i = 0; //这时是一个指针，用于遍历 中缀表达式字符串\n\t\tString str; // 对多位数的拼接\n\t\tchar c; // 每遍历到一个字符，就放入到c\n\t\tdo {\n\t\t\t//如果c是一个非数字，我需要加入到ls\n\t\t\tif((c=s.charAt(i)) < 48 ||  (c=s.charAt(i)) > 57) {\n\t\t\t\tls.add("" + c);\n\t\t\t\ti++; //i需要后移\n\t\t\t} else { //如果是一个数，需要考虑多位数\n\t\t\t\tstr = ""; //先将str 置成"" \'0\'[48]->\'9\'[57]\n\t\t\t\twhile(i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) {\n\t\t\t\t\tstr += c;//拼接\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tls.add(str);\n\t\t\t}\n\t\t}while(i < s.length());\n\t\treturn ls;//返回\n\t}\n\n\t//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中\n\tpublic static List<String> getListString(String suffixExpression) {\n\t\t//将 suffixExpression 分割\n\t\tString[] split = suffixExpression.split(" ");\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(String ele: split) {\n\t\t\tlist.add(ele);\n\t\t}\n\t\treturn list;\n\t\t\n\t}\n\n\t//完成对逆波兰表达式的运算\n\t/*\n\t * 1)从左至右扫描，将3和4压入堆栈；\n\t\t2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；\n\t\t3)将5入栈；\n\t\t4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；\n\t\t5)将6入栈；\n\t\t6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果\n\t */\n\n\tpublic static int calculate(List<String> ls) {\n\t\t// 创建给栈, 只需要一个栈即可\n\t\tStack<String> stack = new Stack<String>();\n\t\t// 遍历 ls\n\t\tfor (String item : ls) {\n\t\t\t// 这里使用正则表达式来取出数\n\t\t\tif (item.matches("\\\\d+")) { // 匹配的是多位数\n\t\t\t\t// 入栈\n\t\t\t\tstack.push(item);\n\t\t\t} else {\n\t\t\t\t// pop出两个数，并运算， 再入栈\n\t\t\t\tint num2 = Integer.parseInt(stack.pop());\n\t\t\t\tint num1 = Integer.parseInt(stack.pop());\n\t\t\t\tint res = 0;\n\t\t\t\tif (item.equals("+")) {\n\t\t\t\t\tres = num1 + num2;\n\t\t\t\t} else if (item.equals("-")) {\n\t\t\t\t\tres = num1 - num2;\n\t\t\t\t} else if (item.equals("*")) {\n\t\t\t\t\tres = num1 * num2;\n\t\t\t\t} else if (item.equals("/")) {\n\t\t\t\t\tres = num1 / num2;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new RuntimeException("运算符有误");\n\t\t\t\t}\n\t\t\t\t//把res 入栈\n\t\t\t\tstack.push("" + res);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t//最后留在stack中的数据是运算结果\n\t\treturn Integer.parseInt(stack.pop());\n\t}\n\n\t}\n\n\t//编写一个类 Operation 可以返回一个运算符 对应的优先级\n\tclass Operation {\n\tprivate static int ADD = 1;\n\tprivate static int SUB = 1;\n\tprivate static int MUL = 2;\n\tprivate static int DIV = 2;\n\n\t//写一个方法，返回对应的优先级数字\n\tpublic static int getValue(String operation) {\n\t\tint result = 0;\n\t\tswitch (operation) {\n\t\tcase "+":\n\t\t\tresult = ADD;\n\t\t\tbreak;\n\t\tcase "-":\n\t\t\tresult = SUB;\n\t\t\tbreak;\n\t\tcase "*":\n\t\t\tresult = MUL;\n\t\t\tbreak;\n\t\tcase "/":\n\t\t\tresult = DIV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println("不存在该运算符" + operation);\n\t\t\tbreak;\n\t\t}\n\t\treturn result;\n\t}\n}\n')])])]),s("h2",{attrs:{id:"_5-7-中缀表达式转换为后缀表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-中缀表达式转换为后缀表达式"}},[t._v("#")]),t._v(" 5.7 中缀表达式转换为后缀表达式")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("   大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发\n中，我们需要将 中缀表达式转成后缀表达式。\n")])])]),s("h3",{attrs:{id:"_5-71具体步骤如下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-71具体步骤如下"}},[t._v("#")]),t._v(" 5.71具体步骤如下:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("1) 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；\n2) 从左至右扫描中缀表达式；\n3) 遇到操作数时，将其压 s2；\n4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级：\n1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；\n2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1；\n3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较；\n5) 遇到括号时：\n (1) 如果是左括号“(”，则直接压入 s1\n (2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃\n6) 重复步骤 2 至 5，直到表达式的最右边\n7) 将 s1 中剩余的运算符依次弹出并压入 s2\n8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式\n")])])]),s("h3",{attrs:{id:"_5-72举例说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-72举例说明"}},[t._v("#")]),t._v(" 5.72举例说明:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('   将中缀表达式“1+(2+3)×4)-5”转换为后缀表达式的过程如下\n因此结果为 :"1 2 3 + 4 × + 5 –"\n')])])]),s("p",[s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/6.jpg",alt:"中缀表达式转换后缀过程"}})]),t._v(" "),s("h3",{attrs:{id:"_5-73代码实现中缀表达式转为后缀表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-73代码实现中缀表达式转为后缀表达式"}},[t._v("#")]),t._v(" 5.73代码实现中缀表达式转为后缀表达式")]),t._v(" "),s("blockquote",[s("p",[t._v("思路分析")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%BA%94%E7%AB%A0_files/7.jpg",alt:"中缀表达式转换后缀思路分析"}})]),t._v(" "),s("h2",{attrs:{id:"_5-8-逆波兰计算器完整版"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-8-逆波兰计算器完整版"}},[t._v("#")]),t._v(" 5.8 逆波兰计算器完整版")]),t._v(" "),s("h3",{attrs:{id:"_5-81完整版的逆波兰计算器，功能包括"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-81完整版的逆波兰计算器，功能包括"}},[t._v("#")]),t._v(" 5.81完整版的逆波兰计算器，功能包括")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("1) 支持 + - * / ( )\n2) 多位数，支持小数, 3) 兼容处理, 过滤任何\n2) 多位数，支持小数, 3) 兼容处理, 过滤任何空白字符，包括空格、制表符、换页符\n说明：逆波兰计算器完整版考虑的因素较多，下面给出完整版代码供同学们学习，其基本思路和前面一样，也\n是使用到：中缀表达式转后缀表达式。\n")])])]),s("blockquote",[s("p",[t._v("代码实现：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.regex.Pattern;\n\npublic class ReversePolishMultiCalc {\n\n\t /**\n\t * 匹配 + - * / ( ) 运算符\n\t */\n\tstatic final String SYMBOL = "\\\\+|-|\\\\*|/|\\\\(|\\\\)";\n\n\tstatic final String LEFT = "(";\n\tstatic final String RIGHT = ")";\n\tstatic final String ADD = "+";\n\tstatic final String MINUS= "-";\n\tstatic final String TIMES = "*";\n\tstatic final String DIVISION = "/";\n\n\t/**\n\t * 加減 + -\n\t */\n\tstatic final int LEVEL_01 = 1;\n\t/**\n\t * 乘除 * /\n\t */\n\tstatic final int LEVEL_02 = 2;\n\n\t/**\n\t * 括号\n\t */\n\tstatic final int LEVEL_HIGH = Integer.MAX_VALUE;\n\n\n\tstatic Stack<String> stack = new Stack<>();\n\tstatic List<String> data = Collections.synchronizedList(new ArrayList<String>());\n\n\t/**\n\t * 去除所有空白符\n\t * @param s\n\t * @return\n\t */\n\tpublic static String replaceAllBlank(String s ){\n\t\t// \\\\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \\f\\n\\r\\t\\v]\n\t\treturn s.replaceAll("\\\\s+","");\n\t}\n\n\t/**\n\t * 判断是不是数字 int double long float\n\t * @param s\n\t * @return\n\t */\n\tpublic static boolean isNumber(String s){\n\t\tPattern pattern = Pattern.compile("^[-\\\\+]?[.\\\\d]*$");\n\t\treturn pattern.matcher(s).matches();\n\t}\n\n\t/**\n\t * 判断是不是运算符\n\t * @param s\n\t * @return\n\t */\n\tpublic static boolean isSymbol(String s){\n\t\treturn s.matches(SYMBOL);\n\t}\n\n\t/**\n\t * 匹配运算等级\n\t * @param s\n\t * @return\n\t */\n\tpublic static int calcLevel(String s){\n\t\tif("+".equals(s) || "-".equals(s)){\n\t\t\treturn LEVEL_01;\n\t\t} else if("*".equals(s) || "/".equals(s)){\n\t\t\treturn LEVEL_02;\n\t\t}\n\t\treturn LEVEL_HIGH;\n\t}\n\n\t/**\n\t * 匹配\n\t * @param s\n\t * @throws Exception\n\t */\n\tpublic static List<String> doMatch (String s) throws Exception{\n\t\tif(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");\n\t\tif(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number");\n\n\t\ts = replaceAllBlank(s);\n\n\t\tString each;\n\t\tint start = 0;\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(isSymbol(s.charAt(i)+"")){\n\t\t\t\teach = s.charAt(i)+"";\n\t\t\t\t//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是( )的优先级 及是 ) 不能直接入栈\n\t\t\t\tif(stack.isEmpty() || LEFT.equals(each)\n\t\t\t\t\t\t|| ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){\n\t\t\t\t\tstack.push(each);\n\t\t\t\t}else if( !stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){\n\t\t\t\t\t//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈\n\t\t\t\t\twhile (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek()) ){\n\t\t\t\t\t\tif(calcLevel(stack.peek()) == LEVEL_HIGH){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata.add(stack.pop());\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(each);\n\t\t\t\t}else if(RIGHT.equals(each)){\n\t\t\t\t\t// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈\n\t\t\t\t\twhile (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){\n\t\t\t\t\t\tif(LEVEL_HIGH == calcLevel(stack.peek())){\n\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata.add(stack.pop());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = i ;    //前一个运算符的位置\n\t\t\t}else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") ){\n\t\t\t\teach = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);\n\t\t\t\tif(isNumber(each)) {\n\t\t\t\t\tdata.add(each);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException("data not match number");\n\t\t\t}\n\t\t}\n\t\t//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列\n\t\tCollections.reverse(stack);\n\t\tdata.addAll(new ArrayList<>(stack));\n\n\t\tSystem.out.println(data);\n\t\treturn data;\n\t}\n\n\t/**\n\t * 算出结果\n\t * @param list\n\t * @return\n\t */\n\tpublic static Double doCalc(List<String> list){\n\t\tDouble d = 0d;\n\t\tif(list == null || list.isEmpty()){\n\t\t\treturn null;\n\t\t}\n\t\tif (list.size() == 1){\n\t\t\tSystem.out.println(list);\n\t\t\td = Double.valueOf(list.get(0));\n\t\t\treturn d;\n\t\t}\n\t\tArrayList<String> list1 = new ArrayList<>();\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tlist1.add(list.get(i));\n\t\t\tif(isSymbol(list.get(i))){\n\t\t\t\tDouble d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));\n\t\t\t\tlist1.remove(i);\n\t\t\t\tlist1.remove(i-1);\n\t\t\t\tlist1.set(i-2,d1+"");\n\t\t\t\tlist1.addAll(list.subList(i+1,list.size()));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdoCalc(list1);\n\t\treturn d;\n\t}\n\n\t/**\n\t * 运算\n\t * @param s1\n\t * @param s2\n\t * @param symbol\n\t * @return\n\t */\n\tpublic static Double doTheMath(String s1,String s2,String symbol){\n\t\tDouble result ;\n\t\tswitch (symbol){\n\t\t\tcase ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;\n\t\t\tcase MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;\n\t\t\tcase TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;\n\t\t\tcase DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;\n\t\t\tdefault : result = null;\n\t\t}\n\t\treturn result;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//String math = "9+(3-1)*3+10/2";\n\t\tString math = "12.8 + (2 - 3.55)*4+10/5.0";\n\t\ttry {\n\t\t\tdoCalc(doMatch(math));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n')])])])])}),[],!1,null,null,null);n.default=i.exports}}]);