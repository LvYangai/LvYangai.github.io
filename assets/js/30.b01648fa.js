(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{350:function(e,n,a){"use strict";a.r(n);var t=a(33),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"简单查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单查询"}},[e._v("#")]),e._v(" 简单查询")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("查询select ，用于从数据表中获取指定的数据\n")])])]),a("h2",{attrs:{id:"语法格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法格式"}},[e._v("#")]),e._v(" 语法格式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("select 显示列名1,显示列名2 ,...显示列名n  from 表名\n注意：\n 1.显示列名默认与表中的字段名是一样的\n 2.显示列可以直接进行数学计算 但要求这个字段的类型必须是数字型\n 3.如果想获取所有的列那么可以使用 * 但是不推荐这么做，因为查询速度回降低，尽可能的需要哪些列就获取那些咧\n")])])]),a("h2",{attrs:{id:"练习01"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习01"}},[e._v("#")]),e._v(" 练习01")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("查询所有的员工名字(ename)\n select ename from emp\n查询所有的员工姓名(ename)以及职位(job)\n select ename,job from emp\n查询所有员工的所有数据\n select * from emp\n查询所有员工的名字以及年薪 （年薪=sal*12）\n select ename,sal*12 from emp\n")])])]),a("h2",{attrs:{id:"显示列设置别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#显示列设置别名"}},[e._v("#")]),e._v(" 显示列设置别名")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("语法格式\n 显示列名 as 别名\n或\n 显示列名  别名\n\n注意：\n 1.如果别名包含特殊字符例如空格 或汉字等等 必须要在别名上添加'' 例如 显示列名 as  '别名'\n")])])]),a("h2",{attrs:{id:"练习02"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习02"}},[e._v("#")]),e._v(" 练习02")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("查询所有员工的名字以及年薪 （年薪=sal*12） 为年薪 添加别名\n select ename,sal*12 '年薪' from emp\n select ename,sal*12 as '年薪' from emp\n")])])]),a("h1",{attrs:{id:"条件查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件查询"}},[e._v("#")]),e._v(" 条件查询")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("根据特定的条件获取数据库表中的数据例如获取性别为男的\n\n\n语法格式\n select 显示列  from 表名 where 字段名 简单运算符 数据\n注意：\n 1.简单运算符包括 =  <  <=  >  >= !=\n 2.数据库中所有的关键字不区分大小写包括表名和 字段名和库名， 但是数据时区分大小写的例如A 和 a就不是一\n   个值可在MySQL中数据也不区分大小写\n 3.在数据库中数字可以使用< <= > >= ，字符串也可以可以使用，字符串会按照字典顺序排列大小\n 4.如果数据为非数字型则需要添加'' 例如字符串和日期格式数据\n")])])]),a("h2",{attrs:{id:"练习03"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习03"}},[e._v("#")]),e._v(" 练习03")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取职位（job）为办事员(CLERK)的所有员工\n select  * from emp where job='CLERK'\n获取所有工资（sal）大于等于1600的所有员工\n select * from emp where sal>=1600\n获取所有不是部门（deptno）20中的所有员工\n select * from emp where deptno!=20\n\n\nbetween ⋯ and ⋯ 运算符获取某个区间范围内容的数据\n语法格式\n 字段名 between 开始值 and 结束值\n注意：\n 1.只能应用于数字字段\n 2.它会包含开始值和结束值\n")])])]),a("h2",{attrs:{id:"练习04"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习04"}},[e._v("#")]),e._v(" 练习04")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取工资在1600到3000之间的所有员工\n select * from emp where sal between 1600 and 3000;\n\n is null 获取列为null的数据\n语法格式\n 字段名 is null\n注意：\n 1.如果需要获取某个列为null的数据时不能使用 字段名=null或字段名 ='null'\n 2.is null 只能获取数据本身为null 但不能获取数据内容为null的数据\n")])])]),a("h2",{attrs:{id:"练习05"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习05"}},[e._v("#")]),e._v(" 练习05")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取所有的没有津贴的员工\n select  * from emp  where comm is null \n获取公司中的最高领导\n select * from emp where mgr is null\n\n\n\nand 和 or 运算符号\nand 要求两侧的条件都真这条才会被获取 相当于Java中的 &&\nor 要求两侧的条件有一个为真数据就会被获取  相当于Java中的||\n\n语法格式\n 字段名 = 数据 and 字段名 = 数据  ...\n 字段名 = 数据 or  字段名 = 数据  ...\n\n注意：\n 1.由于and的优先级比or要高因此实际应用中可以根据业务的逻辑适当的添加()提升优先级\n")])])]),a("h2",{attrs:{id:"练习06"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习06"}},[e._v("#")]),e._v(" 练习06")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取工资大于1600 并且小于等于3000的所有员工\n select * from emp where sal >1600 and sal<=3000\n获取职位是办事员（CLERK） 或者 职位为 销售员（SALESMAN）的所有员工\n select * from emp where job='CLERK' or job='SALESMAN'\n获取部门20和部门30中所有的办事员（CLERK）\n select * from emp where deptno=20 and job='CLERK' or deptno =30 and job='CLERK'\n错误的：由于and的优先级比or要高所有SQL会先执行and 获取出部门30中的办事员及部门20中的所有员工\n select * from emp where deptno=20 or deptno=30  and job='CLERK'\n正确的：提升or的优先级\n select * from emp where (deptno=20 or deptno=30)  and job='CLERK'\n\n\nin 运算符  获取所有包含在某个范围内的所有数据\n\n语法格式\n 字段名 in (数据1,数据2...,数据n)\n注意：\n 1.in的底层业务逻辑规则与or 是相同的\n 2.由于or的运算速度比较慢，因此在实际应用时尽可的避免or和in的使用\n")])])]),a("h2",{attrs:{id:"练习07"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习07"}},[e._v("#")]),e._v(" 练习07")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取职位是办事员（CLERK） 或者 职位为 销售员（SALESMAN）的所有员工\n select * from emp where job in ('CLERK','SALESMAN')\n\n\n\nnot 运算符 表示取反的意思必须配合 is null  或 in 一起使用才有效\nnot in 表示不包含在某个范围内容\n语法格式\n 字段名 not in (数据1,数据2...,数据n)\n注意：\n 1.not in 的底层业务逻辑规则与 and 是相同\n   \n is not null 表示不为空的\n语法格式\n 字段名 is not null\n")])])]),a("h2",{attrs:{id:"练习08"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习08"}},[e._v("#")]),e._v(" 练习08")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取职位不是办事员（CLERK） 或者 职位不是销售员（SALESMAN）的所有员工\n select *  from emp where job not in('CLERK','SALESMAN')\n\n获取所有拥有津贴的员工\n select * from emp where comm is not null\n\nlike 模糊查找匹配数据 必须与% 或_一起使用才有效\n语法格式\n 字段名  like '%数据'\n 字段名  like '%数据%'\n 字段名  like '数据%'\n 字段名  like '_数据_'\n .....\n注意：\n % 表示 匹配任意字符任意个数 \n _ 表示 匹配任意字符1个\n")])])]),a("h2",{attrs:{id:"练习09"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习09"}},[e._v("#")]),e._v(" 练习09")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取员工姓名是已A开头\n select * from emp where ename like 'A%'\n获取员工姓名包含A的\n select * from emp where ename like '%A%'\n获取员工姓名是以S结尾\n select * from emp where ename like '%S'\n获取员工姓名是5个字符的\n select * from emp where ename like '_____'\n")])])]),a("h1",{attrs:{id:"排序order-by"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序order-by"}},[e._v("#")]),e._v(" 排序order by")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("根据某一个或多列的数据进行降序或升序排序\n语法格式\n select 显示列 from 表名 [where 条件] order by 字段名1 [排序规则],字段名2 [排序规则]...字段名n [排序规则]\n\n注意：\n 1.排序时可以根据一列或多个列同时排序，如果第一个列的值相同那么才会根据第二列排序\n 2.可以对数字排序 ，可以对日期排序 日期越早值越小 ，如果越晚值越大，可以根据字符串排序它按照字典顺序排序\n 3.排序规则，每个排序规则只能影响它前面一个字段，排序规则是可选的默认是升序。取值为 asc 升序、 desc降序\n")])])]),a("h2",{attrs:{id:"练习10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习10"}},[e._v("#")]),e._v(" 练习10")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取所有的员工信息根据工资降序\n select * from emp order by sal desc\n获取所有的员工，根据部门编号升序后根据工资降序\n select * from emp order by deptno , sal desc\n根据入职时间（hiredate）升序排序\n select * from emp order by hiredate \n")])])]),a("h2",{attrs:{id:"聚合函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚合函数"}},[e._v("#")]),e._v(" 聚合函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("将多行中的某一列的值聚合成一行数据\n count(字段名)   根据字段名统计数量返回一个数字 也可将字段名替换成 * 但是效率不高\n sum(字段名)  将多行的指定列值相加求和 只能应用于数字列上\n avg(字段名) 将多行的指定列值相加然后取平局值 只能应用于数字列上\n max(字段名)  获取当前列的最大值可以应用在数字 字符串和日期以上  \n min(字段名) 获取当前列的最小值可以应用在数字 字符串和日期以上  \n语法格式：\n select 函数名(字段名),函数名(字段名)...,函数名(字段名) from 表名 [where] [order by]\n注意：\n 1.所有的聚合函数都会自动的忽略掉为null的数据\n 2.当显示列中使用了聚合函数以后那么现显示中不能出现非聚合的数据否则会出现错误，但是MySQL不会出现错误但是\n   返回的数据是不正确的\n 3.where 的后面不能直接使用聚合函数\n")])])]),a("h2",{attrs:{id:"练习11"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习11"}},[e._v("#")]),e._v(" 练习11")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("统计公司所有的人数\n select count(empno) from emp\n获取工资的平局值\n select avg(sal) from emp\n获取部门20的工资平均值\n select avg(sal) from emp where deptno=20\n获取入职时间最早的时间\n select min(hiredate) from emp\n获取工资高于公司平均工资的所有员工\n 错误的 这道题暂时无法实现\n select * from emp where sal>avg(sal)\n")])])]),a("h1",{attrs:{id:"分组查询-grop-by"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分组查询-grop-by"}},[e._v("#")]),e._v(" 分组查询 grop by-----------------------------------------")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("可以根据一个列或多个列同时进行分组 分组后会将这些列数据完全相同的行聚合成一行记录，因此显示列\n中不能填写非分组数据或非聚合数据\n语法格式\n select 显示列 from 表名 [where] group by 字段名1,字段名2...,字段名n [having 字段名 运算符 数据] [order by]\n\n注意：\n 1.分组后显示列中不能出现非分组数据和非聚合数据\n 2.where 是分组前的条件筛选 having是分组后条件筛选 having中可以使用聚合函数\n 3.分组后order by中可以使用聚合函数进行排序\n")])])]),a("h2",{attrs:{id:"练习12"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习12"}},[e._v("#")]),e._v(" 练习12")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取各个部门中工资的平均值 显示部门编号和平均工资\n select deptno, avg(sal) from emp  group by deptno\t\n获取平均工资大于1500的所有职位以及职位的平均工资\n select job ,avg(sal) from emp group by job having avg(sal)>1500\n\n获取各个部门中各个职位的平均工资，显示部门编号 职位  平均工资\n select deptno,job ,avg(sal)  from emp group by deptno,job \n\n获取部门30中各个职位的平均工资\n select job,avg(sal)  from  emp where deptno=30 group by job\n")])])]),a("h1",{attrs:{id:"连接查询-多表查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接查询-多表查询"}},[e._v("#")]),e._v(" 连接查询 /多表查询")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("一条查询语句中拥有多个表，同时查询多个表中的数据，有2中语法 为92语法和99语法\n")])])]),a("h3",{attrs:{id:"_92语法多表查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_92语法多表查询"}},[e._v("#")]),e._v(" 92语法多表查询")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("语法格式\n select 显示列 from 表名1 [别名],表名2 [别名]  where 条件  [group by [having]] [order by]\n")])])]),a("h2",{attrs:{id:"练习13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习13"}},[e._v("#")]),e._v(" 练习13")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取所有的员工信息以及部门信息\n 错误的：这条语句会出现笛卡尔积问题，笛卡尔积指多表查询时获取的记录内容是所有的表记录乘积，这表中所有的数据\n        会逐一进行匹配，表越多数据越多那么获取的数据积也就越多\n select * from emp e,dept d\n解决方案使用92语法\n 需要在语句的后面添加一个where 的条件，我们需要利用这个条件获取对应的数据\n where条件的数量至少是表数量-1个，而且必须使用多表之间的关联列消除笛卡尔积例如emp和dept表中的deptno就是关联列\n\nselect * from emp e,dept d  where e.deptno=d.deptno\n注意：\n 1.在多表查询时推荐为表名添加别名然后使用别名.字段名 ，这是为了防止这些表中会出现同名的字段名\n")])])]),a("h2",{attrs:{id:"_99语法实现多表查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_99语法实现多表查询"}},[e._v("#")]),e._v(" 99语法实现多表查询")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("语法格式\n内连接\n select 显示列 from 表名1 别名 inner join 表名2 别名 on 条件 inner join 表名3 别名 on 条件 ... [where] [group by[having]] [order by]\n左外连接 \n select 显示列 from 表名1 别名 left outer join 表名2 别名 on 条件 left outer join 表名3 别名 on 条件 ... [where] [group by[having]] [order by] \n右外连接 \n select 显示列 from 表名1 别名 right outer join 表名2 别名 on 条件 right outer join 表名3 别名 on 条件 ... [where] [group by[having]] [order by] \n\n注意：\n 1. inner 和 outer 可以省略不写\n 2.99语法的内连接获取的数据与92语法是完全一样\n 3.左外连接和右外连接是相互的作用是当前2个表的数据不能完全匹配时，\n   如果需要让左侧的表多显示数据那就用用左外否则就是用右外\n 4.on 后面的条件可以使用and 或or 同时添加多个\n")])])]),a("h2",{attrs:{id:"练习14"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习14"}},[e._v("#")]),e._v(" 练习14")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("获取所有的员工信息以及部门信息\n select * from emp e inner join dept d on e.deptno=d.deptno    \n或\n select * from emp e  join dept d on e.deptno=d.deptno   \n\n获取所有员工信息和部门信息同时显示没有员工的部门信息\n右外连接\n select * from emp e right outer join dept d on e.deptno=d.deptno\n或\n select * from emp e right  join dept d on e.deptno=d.deptno\n\n左外连接\n select * from  dept d left outer join emp e on e.deptno=d.deptno \n或\n select * from  dept d left  join emp e on e.deptno=d.deptno\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);