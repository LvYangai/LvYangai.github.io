(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{342:function(n,e,t){"use strict";t.r(e);var r=t(33),i=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"第-4-章-链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第-4-章-链表"}},[n._v("#")]),n._v(" 第 4 章 链表")]),n._v(" "),t("h2",{attrs:{id:"_4-1-链表-linked-list-介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-链表-linked-list-介绍"}},[n._v("#")]),n._v(" 4.1 链表(Linked List)介绍")]),n._v(" "),t("p",[n._v("链表是有序的列表，但是它在内存中是存储如下")]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/1.jpg",alt:"链表"}})]),n._v(" "),t("blockquote",[t("p",[n._v("小结上图:")])]),n._v(" "),t("ul",[t("li",[t("ol",[t("li",[n._v("链表是以节点的方式来存储,是链式存储")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[n._v("每个节点包含    data   域，    next   域：指向下一个节点.")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[n._v("如图：发现链表的各个节点不一定是连续存储.")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"4"}},[t("li",[n._v("链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定")])])])]),n._v(" "),t("blockquote",[t("p",[n._v("单链表(带头结点)   逻辑结构示意图如下")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/2.jpg",alt:"带头结点-单链表"}})]),n._v(" "),t("h2",{attrs:{id:"_4-2-单链表的应用实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-单链表的应用实例"}},[n._v("#")]),n._v(" 4.2 单链表的应用实例")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("   使用带  head  头的单向链表实现    –水浒英雄排行榜管理完成对英雄人物的增删改查操作 \n注:   删除和修改,查找 可以考虑学员独立完成，也可带学员完成 \n1) 第一种方法在添加英雄时，直接添加到链表的尾部 \n")])])]),t("blockquote",[t("p",[n._v("思路分析示意图:\n"),t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/3.jpg",alt:"单链表创建示意图"}})])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("2) 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) \n")])])]),t("blockquote",[t("p",[n._v("思路的分析示意图:\n"),t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/4.jpg",alt:"添加节点"}})])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("3) 修改节点功能 \n思路：\n (1)   先找到该节点，通过遍历，\n (2) temp.name  = newHeroNode.name  ;  temp.nickname=  newHeroNode.nickname \n4) 删除节点 \n")])])]),t("blockquote",[t("p",[n._v("思路分析的示意图:")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/5.jpg",alt:"删除节点"}})]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('5) 完成的代码演示: \n\npackage com.lyg.four;\nimport java.util.Stack;\n\n/**\n * @program: DataStructure\n * @description: 单向链表\n * @author: LvYangai\n * @create: 2020-06-21 14:47\n * @e-mail: 1076977275@qq.com\n **/\npublic class SingleLinkedListDemo {\n    public static void main(String[] args) {\n        //测试\n        //先创建节点\n        HeroNode heroNode1 = new HeroNode(1,"宋江","及时雨");\n        HeroNode heroNode2 = new HeroNode(2,"卢俊义","玉麒麟");\n        HeroNode heroNode3 = new HeroNode(3,"吴用","智多星");\n        HeroNode heroNode4 = new HeroNode(4,"林冲","豹子头");\n        //创建要给链表\n        SingleLinkedList singleLinkedList = new SingleLinkedList();\n        //加入\n        singleLinkedList.addByOrder(heroNode3);\n        singleLinkedList.addByOrder(heroNode2);\n        singleLinkedList.addByOrder(heroNode1);\n        singleLinkedList.addByOrder(heroNode4);\n        singleLinkedList.addByOrder(heroNode2);\n        singleLinkedList.list();\n\n        System.out.println("修改后");\n        //修改\n        singleLinkedList.update(new HeroNode(4,"阿林","豹子头"));\n        singleLinkedList.list();\n\n        //删除\n        System.out.println("删除后");\n\n        singleLinkedList.del(4);\n        singleLinkedList.list();\n    }\n\n\n}\n//定义SingleLinkedList 管理我们但英雄\nclass SingleLinkedList{\n    //初始化一个头节点，头节点不能动\n    private HeroNode head = new HeroNode(0,"","");\n    //添加节点到单向链表\n    //思路，当不考虑编号顺序式\n    //1.找到当前链表到最后节点\n    //2.将最后这个节点的next 指向 新的节点\n    public void add(HeroNode heroNode){\n        //判断节点是否为空\n        //因为节点不能动，因此我们需要一个辅助遍历temp\n        HeroNode temp = head;\n        while(temp.next != null){\n            temp = temp.next;\n        }\n        temp.next = heroNode;\n    }\n    //遍历显示节点\n    public void list(){\n        //判断链表是否为空\n        if (head.next == null){\n            System.out.println("链表为空");\n            return;\n        }\n        //辅助节点遍历\n        HeroNode temp = head.next;\n        while (temp != null){\n            System.out.println(temp);\n            temp = temp.next;\n        }\n    }\n    //第二种添加方式在添加英雄时，根据排名将英雄插入到指定位置\n    //如果有这个排名，则添加失败，并给出提示\n    public void addByOrder(HeroNode heroNode){\n        //因为头节点不能动  所以需要辅助节点\n        //因为单链表找的temp是位于添加位置的前一个节点，否则插入不了\n        HeroNode temp = head;\n        while (temp.next != null){\n            if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在\n                System.out.printf("准备插入的英雄编号%d已经存在了\\n",heroNode.no);\n               return;\n            }else if (temp.next.no > heroNode.no){\n                break;\n            }\n            temp = temp.next;\n        }\n        //插入到链表\n        heroNode.next = temp.next;\n        temp.next = heroNode;\n\n    }\n    //修改节点信息，根据no 编号来修改，即no编号不能改\n    //说明\n    //1.根据newHeroNode的no来修改\n    public void update(HeroNode newHeroNode){\n        //判断是否为空\n        if (head.next == null){\n            System.out.println("链表为空");\n            return;\n        }\n        //找到需要修改的节点，根据NO编号\n        //定义一个辅助变量\n        HeroNode temp = head.next;\n        boolean flag = false; //表示是否找到该节点\n        while(true) {\n            if (temp == null) {\n                break; //已经遍历完链表\n            }\n            if(temp.no == newHeroNode.no) {\n                //找到\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        //根据flag 判断是否找到要修改的节点\n        if(flag) {\n            temp.name = newHeroNode.name;\n            temp.nickname = newHeroNode.nickname;\n        } else { //没有找到\n            System.out.printf("没有找到 编号 %d 的节点，不能修改\\n", newHeroNode.no);\n        }\n    }\n    //删除节点\n    //\n    public void del(int no){\n        HeroNode temp = head;\n        while ( temp.next != null && temp.next.no != no){\n            temp = temp.next;\n        }\n        if (temp.next.no == no){\n            temp.next = temp.next.next;\n        }else {\n            System.out.println("要删除的节点没有找到");\n        }\n    }\n\n\n}\n\n//定义HeroNode ，每个HeroNode 对象就是一个节点\nclass HeroNode{\n    public int no;\n    public String name;\n    public String nickname;\n    public HeroNode next;\n\n\n\n    //构造器\n    public HeroNode(int no, String name, String nickname) {\n        this.no = no;\n        this.name = name;\n        this.nickname = nickname;\n    }\n\n    @Override\n    public String toString() {\n        return "HeroNode{" +\n                "no=" + no +\n                ", name=\'" + name + \'\\\'\' +\n                ", nickname=\'" + nickname + \'\\\'\' +\n                \'}\';\n    }\n}\n')])])]),t("h2",{attrs:{id:"_4-3-单链表面试题-新浪、百度、腾讯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-单链表面试题-新浪、百度、腾讯"}},[n._v("#")]),n._v(" 4.3 单链表面试题(新浪、百度、腾讯)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("单链表的常见面试题有如下:\n")])])]),t("h3",{attrs:{id:"_1-求单链表中有效节点的个数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-求单链表中有效节点的个数"}},[n._v("#")]),n._v(" 1) 求单链表中有效节点的个数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("代码如下：\n\n\n\t//方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)\n\t/**\n\t * \n\t * @param head 链表的头节点\n\t * @return 返回的就是有效节点的个数\n\t */\n\tpublic static int getLength(HeroNode head) {\n\t\tif(head.next == null) { //空链表\n\t\t\treturn 0;\n\t\t}\n\t\tint length = 0;\n\t\t//定义一个辅助的变量, 这里我们没有统计头节点\n\t\tHeroNode cur = head.next;\n\t\twhile(cur != null) {\n\t\t\tlength++;\n\t\t\tcur = cur.next; //遍历\n\t\t}\n\t\treturn length;\n\t}\n")])])]),t("h3",{attrs:{id:"_2-查找单链表中的倒数第-k-个结点-【新浪面试题】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-查找单链表中的倒数第-k-个结点-【新浪面试题】"}},[n._v("#")]),n._v(" 2) 查找单链表中的倒数第 k 个结点 【新浪面试题】")]),n._v(" "),t("blockquote",[t("p",[n._v("代码演示")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("//查找单链表中的倒数第k个结点 【新浪面试题】\n//思路\n//1. 编写一个方法，接收head节点，同时接收一个index \n//2. index 表示是倒数第index个节点\n//3. 先把链表从头到尾遍历，得到链表的总的长度 getLength\n//4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到\n//5. 如果找到了，则返回该节点，否则返回nulll\npublic static HeroNode findLastIndexNode(HeroNode head, int index) {\n\t//判断如果链表为空，返回null\n\tif(head.next == null) {\n\t\treturn null;//没有找到\n\t}\n\t//第一个遍历得到链表的长度(节点个数)\n\tint size = getLength(head);\n\t//第二次遍历  size-index 位置，就是我们倒数的第K个节点\n\t//先做一个index的校验\n\tif(index <=0 || index > size) {\n\t\treturn null; \n\t}\n\t//定义给辅助变量， for 循环定位到倒数的index\n\tHeroNode cur = head.next; //3 // 3 - 1 = 2\n\tfor(int i =0; i< size - index; i++) {\n\t\tcur = cur.next;\n\t}\n\treturn cur;\n\t\n}\n")])])]),t("h3",{attrs:{id:"_3-单链表的反转【腾讯面试题，有点难度】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-单链表的反转【腾讯面试题，有点难度】"}},[n._v("#")]),n._v(" 3) 单链表的反转【腾讯面试题，有点难度】")]),n._v(" "),t("blockquote",[t("p",[n._v("思路分解图")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/6.jpg",alt:"腾讯面试题"}})]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/7.jpg",alt:"腾讯面试题思路"}})]),n._v(" "),t("blockquote",[t("p",[n._v("代码实现\n//将单链表反转\npublic static void reversetList(HeroNode head) {\n//如果当前链表为空，或者只有一个节点，无需反转，直接返回\nif(head.next == null || head.next.next == null) {\nreturn ;\n}")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('\t//定义一个辅助的指针(变量)，帮助我们遍历原来的链表\n\tHeroNode cur = head.next;\n\tHeroNode next = null;// 指向当前节点[cur]的下一个节点\n\tHeroNode reverseHead = new HeroNode(0, "", "");\n\t//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端\n\t//动脑筋\n\twhile(cur != null) { \n\t\tnext = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用\n\t\tcur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端\n\t\treverseHead.next = cur; //将cur 连接到新的链表上\n\t\tcur = next;//让cur后移\n\t}\n\t//将head.next 指向 reverseHead.next , 实现单链表的反转\n\thead.next = reverseHead.next;\n}\n')])])]),t("blockquote",[t("p",[n._v("代码运行图解（自己手动画图）")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/8.jpg",alt:"手动图解"}})]),n._v(" "),t("h3",{attrs:{id:"_4-从尾到头打印单链表-【百度，要求方式-1：反向遍历-。-方式-2：stack-栈】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-从尾到头打印单链表-【百度，要求方式-1：反向遍历-。-方式-2：stack-栈】"}},[n._v("#")]),n._v(" 4) 从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】")]),n._v(" "),t("blockquote",[t("p",[n._v("思路分析图解")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/9.jpg",alt:"栈"}})]),n._v(" "),t("blockquote",[t("p",[n._v("代码演示")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("//方式2\n//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果\npublic static void reversePrint(HeroNode head) {\n\tif(head.next == null) {\n\t\treturn;//空链表，不能打印\n\t}\n\t//创建要给一个栈，将各个节点压入栈\n\tStack<HeroNode> stack = new Stack<HeroNode>();\n\tHeroNode cur = head.next;\n\t//将链表的所有节点压入栈\n\twhile(cur != null) {\n\t\tstack.push(cur);\n\t\tcur = cur.next; //cur后移，这样就可以压入下一个节点\n\t}\n\t//将栈中的节点进行打印,pop 出栈\n\twhile (stack.size() > 0) {\n\t\tSystem.out.println(stack.pop()); //stack的特点是先进后出\n\t}\n}\n")])])]),t("h2",{attrs:{id:"_4-双向链表应用实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-双向链表应用实例"}},[n._v("#")]),n._v(" 4. 双向链表应用实例")]),n._v(" "),t("h3",{attrs:{id:"_4-1双向链表的操作分析和实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1双向链表的操作分析和实现"}},[n._v("#")]),n._v(" 4.1双向链表的操作分析和实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("使用带 head 头的双向链表实现 –水浒英雄排行榜\n")])])]),t("blockquote",[t("p",[n._v("管理单向链表的缺点分析:\n1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。\n2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除\n时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). 3) 分析了双向链表如何完成遍历，添加，修改和删除的思路\n点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/10.jpg",alt:"双向链表"}})]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("对上图的说明:\n  分析 双向链表的遍历，添加，修改，删除的操作思路=》代码实现\n\t1) 遍历 方和 单链表一样，只是可以向前，也可以向后查找\n\t2) 添加 (默认添加到双向链表的最后)\n(1) 先找到双向链表的最后这个节点\n(2) temp.next = newHeroNde\n(3) newHeroNde.pre = temp;\n\n\t3) 修改 思路和 原来的单向链表一样. \n\t4) 删除\n3) 修改 \n(1) 因为是双向链表，因此，我们可以实现自我删除某个节点\n(2) 直接找到要删除的这个节点，比如 temp\n(3) temp.re.nxt =emp.next\n(4) temp.next.pre = temp.re;\n")])])]),t("blockquote",[t("p",[n._v("双向链表的代码实现")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('package com.lyg.four;\n\n/**\n * @program: DataStructure\n * @description: 双向链表\n * @author: LvYangai\n * @create: 2020-06-22 13:03\n * @e-mail: 1076977275@qq.com\n **/\npublic class DoubleLinkedListDemo {\n    public static void main(String[] args) {\n        // 测试\n        System.out.println("双向链表的测试");\n        // 先创建节点\n        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");\n        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");\n        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");\n        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");\n        // 创建一个双向链表\n        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();\n        doubleLinkedList.add(hero1);\n        doubleLinkedList.add(hero2);\n        doubleLinkedList.add(hero3);\n        doubleLinkedList.add(hero4);\n\n        doubleLinkedList.list();\n\n        // 修改\n        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");\n        doubleLinkedList.update(newHeroNode);\n        System.out.println("修改后的链表情况");\n        doubleLinkedList.list();\n\n        // 删除\n        doubleLinkedList.del(4);\n        System.out.println("删除后的链表情况~~");\n        doubleLinkedList.list();\n    }\n}\nclass DoubleLinkedList{\n    //初始化一个头节点，头节点不能动\n    private HeroNode2 head = new HeroNode2(0,"","");\n\n\n\n    //遍历显示节点\n    public void list(){\n        //判断链表是否为空\n        if (head.next == null){\n            System.out.println("链表为空");\n            return;\n        }\n        //辅助节点遍历\n        HeroNode2 temp = head.next;\n        while (temp != null){\n            System.out.println(temp);\n            temp = temp.next;\n        }\n    }\n    //添加\n    public void add(HeroNode2 heroNode){\n        //判断节点是否为空\n        //因为节点不能动，因此我们需要一个辅助遍历temp\n        HeroNode2 temp = head;\n        while(temp.next != null){\n            temp = temp.next;\n        }\n        temp.next = heroNode;\n        heroNode.pre = temp;\n    }\n    //修改\n    public void update(HeroNode2 newHeroNode){\n        //判断是否为空\n        if (head.next == null){\n            System.out.println("链表为空");\n            return;\n        }\n        //找到需要修改的节点，根据NO编号\n        //定义一个辅助变量\n        HeroNode2 temp = head.next;\n        boolean flag = false; //表示是否找到该节点\n        while(true) {\n            if (temp == null) {\n                break; //已经遍历完链表\n            }\n            if(temp.no == newHeroNode.no) {\n                //找到\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        //根据flag 判断是否找到要修改的节点\n        if(flag) {\n            temp.name = newHeroNode.name;\n            temp.nickName = newHeroNode.nickName;\n        } else { //没有找到\n            System.out.printf("没有找到 编号 %d 的节点，不能修改\\n", newHeroNode.no);\n        }\n    }\n    //删除节点\n    public void del(int no){\n        if(head.next == null){\n            System.out.println("链表为空，不能删除");\n            return;\n        }\n        HeroNode2 temp = head.next;\n        boolean flag = false;\n        while(true){\n            if (temp == null){\n                break;\n            }\n            if (temp.no == no){\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        if (flag){\n            temp.pre.next = temp.next;\n            if (temp.next != null){\n                temp.next.pre = temp.pre;\n            }\n        }else {\n            System.out.println("要删除的节点"+no+"不存在");\n        }\n\n    }\n}\n//定义HeroNode2 （双向链表）,每个HeroNode 对象就是一个节点\nclass HeroNode2{\n    public int no;\n    public String name;\n    public String nickName;\n    public HeroNode2 next;//后一个节点\n    public HeroNode2 pre;//前一个节点\n\n    //构造器\n    public HeroNode2(int no, String name, String nickName) {\n        this.no = no;\n        this.name = name;\n        this.nickName = nickName;\n    }\n    //为了显示方法  我们重写toString\n\n    @Override\n    public String toString() {\n        return "HeroNode2{" +\n                "no=" + no +\n                ", name=\'" + name + \'\\\'\' +\n                ", nickName=\'" + nickName + \'\\\'\' +\n                \'}\';\n    }\n}\n')])])]),t("h3",{attrs:{id:"_4-2课堂作业和思路提示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2课堂作业和思路提示"}},[n._v("#")]),n._v(" 4.2课堂作业和思路提示")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("双向链表的第二种添加方式,按照编号顺序 [示意图]按照单链表的顺序添加，稍作修改即可.\n")])])]),t("h2",{attrs:{id:"_4-5-单向环形链表应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-单向环形链表应用场景"}},[n._v("#")]),n._v(" 4.5 单向环形链表应用场景")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("Josephu(约瑟夫、约瑟夫环) 问题\n   Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数\n到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由\n此产生一个出队编号的序列。\n提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结\n点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直\n到最后一个结点从链表中删除算法结束。\n")])])]),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/11.jpg",alt:"单向环形链表"}})]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/12.jpg",alt:"单向环形链表2"}})]),n._v(" "),t("h2",{attrs:{id:"_4-7-josephu-问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-josephu-问题"}},[n._v("#")]),n._v(" 4.7 Josephu 问题")]),n._v(" "),t("blockquote",[t("p",[n._v("约瑟夫问题的示意图")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/13.jpg",alt:"Josephu环"}})]),n._v(" "),t("blockquote",[t("p",[n._v("Josephu 问题")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("   Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数到\nm 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此\n产生一个出队编号的序列。\n")])])]),t("blockquote",[t("p",[n._v("提示")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("   用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开\n始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个\n结点从链表中删除算法结束。\n")])])]),t("blockquote",[t("p",[n._v("约瑟夫问题-创建环形链表的思路图解")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/14.jpg",alt:"创建环形链表的思路图解"}})]),n._v(" "),t("blockquote",[t("p",[n._v("约瑟夫问题-小孩出圈的思路分析图")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0_files/15.jpg",alt:"小孩出圈的思路分析图"}})]),n._v(" "),t("h2",{attrs:{id:"_4-8-josephu-问题的代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-josephu-问题的代码实现"}},[n._v("#")]),n._v(" 4.8 Josephu 问题的代码实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('package com.lyg.four;\n\n/**\n * @program: DataStructure\n * @description: 约瑟夫环形链表\n * @author: LvYangai\n * @create: 2020-06-22 14:19\n * @e-mail: 1076977275@qq.com\n **/\npublic class Josepfu {\n    public static void main(String[] args) {\n        CircleSingleLinkedList linkeList = new CircleSingleLinkedList();\n        linkeList.addBoy(5);\n        linkeList.showBoy();\n        linkeList.countBoy(1,2,5);\n    }\n}\n\n// 创建一个环形的单向链表\nclass CircleSingleLinkedList {\n    // 创建一个first节点,当前没有编号\n    private Boy first = null;\n\n    // 添加小孩节点，构建成一个环形的链表\n    public void addBoy(int nums) {\n        // nums 做一个数据校验\n        if (nums < 1) {\n            System.out.println("nums的值不正确");\n            return;\n        }\n        Boy curBoy = null; // 辅助指针，帮助构建环形链表\n        // 使用for来创建我们的环形链表\n        for (int i = 1; i <= nums; i++) {\n            // 根据编号，创建小孩节点\n            Boy boy = new Boy(i);\n            // 如果是第一个小孩\n            if (i == 1) {\n                first = boy;\n                first.setNext(first); // 构成环\n                curBoy = first; // 让curBoy指向第一个小孩\n            } else {\n                curBoy.setNext(boy);//\n                boy.setNext(first);//\n                curBoy = boy;\n            }\n        }\n    }\n\n    // 遍历当前的环形链表\n    public void showBoy() {\n        // 判断链表是否为空\n        if (first == null) {\n            System.out.println("没有任何小孩~~");\n            return;\n        }\n        // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历\n        Boy curBoy = first;\n        while (true) {\n            System.out.printf("小孩的编号 %d \\n", curBoy.getNo());\n            if (curBoy.getNext() == first) {// 说明已经遍历完毕\n                break;\n            }\n            curBoy = curBoy.getNext(); // curBoy后移\n        }\n    }\n\n    // 根据用户的输入，计算出小孩出圈的顺序\n    /**\n     *\n     * @param startNo\n     *            表示从第几个小孩开始数数\n     * @param countNum\n     *            表示数几下\n     * @param nums\n     *            表示最初有多少小孩在圈中\n     */\n    public void countBoy(int startNo, int countNum, int nums) {\n        // 先对数据进行校验\n        if (first == null || startNo < 1 || startNo > nums) {\n            System.out.println("参数输入有误， 请重新输入");\n            return;\n        }\n        // 创建要给辅助指针,帮助完成小孩出圈\n        Boy helper = first;\n        // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点\n        while (true) {\n            if (helper.getNext() == first) { // 说明helper指向最后小孩节点\n                break;\n            }\n            helper = helper.getNext();\n        }\n        //小孩报数前，先让 first 和  helper 移动 k - 1次\n        for(int j = 0; j < startNo - 1; j++) {\n            first = first.getNext();\n            helper = helper.getNext();\n        }\n        //当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈\n        //这里是一个循环操作，知道圈中只有一个节点\n        while(true) {\n            if(helper == first) { //说明圈中只有一个节点\n                break;\n            }\n            //让 first 和 helper 指针同时 的移动 countNum - 1\n            for(int j = 0; j < countNum - 1; j++) {\n                first = first.getNext();\n                helper = helper.getNext();\n            }\n            //这时first指向的节点，就是要出圈的小孩节点\n            System.out.printf("小孩%d出圈\\n", first.getNo());\n            //这时将first指向的小孩节点出圈\n            first = first.getNext();\n            helper.setNext(first); //\n\n        }\n        System.out.printf("最后留在圈中的小孩编号%d \\n", first.getNo());\n\n    }\n}\n\n// 创建一个Boy类，表示一个节点\nclass Boy {\n    private int no;// 编号\n    private Boy next; // 指向下一个节点,默认null\n\n    public Boy(int no) {\n        this.no = no;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public Boy getNext() {\n        return next;\n    }\n\n    public void setNext(Boy next) {\n        this.next = next;\n    }\n}\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);