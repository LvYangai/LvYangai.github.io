(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{340:function(t,n,r){"use strict";r.r(n);var i=r(33),a=Object(i.a)({},(function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"第-8-章-查找算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-8-章-查找算法"}},[t._v("#")]),t._v(" 第 8 章 查找算法")]),t._v(" "),r("h2",{attrs:{id:"_8-1-查找算法介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-查找算法介绍"}},[t._v("#")]),t._v(" 8.1 查找算法介绍")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("在 java 中，我们常用的查找有四种:\n 1) 顺序(线性)查找\n 2) 二分查找/折半查找\n 3) 插值查找\n 4) 斐波那契查找\n")])])]),r("h2",{attrs:{id:"_8-2-线性查找算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-线性查找算法"}},[t._v("#")]),t._v(" 8.2 线性查找算法")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v('有一个数列： {1,8 10, 89, 10, 1234} ，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提\n示找到，并给出下标值。\n代码实现：\npublic class SeqSearch {\n\n\tpublic static void main(String[] args) {\n\t\tint arr[] = { 1, 9, 11, -1, 34, 89 };// 没有顺序的数组\n\t\tint index = seqSearch(arr, -11);\n\t\tif(index == -1) {\n\t\t\tSystem.out.println("没有找到到");\n\t\t} else {\n\t\t\tSystem.out.println("找到，下标为=" + index);\n\t\t}\n\t}\n\n\t/**\n\t * 这里我们实现的线性查找是找到一个满足条件的值，就返回\n\t * @param arr\n\t * @param value\n\t * @return\n\t */\n\tpublic static int seqSearch(int[] arr, int value) {\n\t\t// 线性查找是逐一比对，发现有相同值，就返回下标\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif(arr[i] == value) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n}\n')])])]),r("h2",{attrs:{id:"_8-3-二分查找算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-二分查找算法"}},[t._v("#")]),t._v(" 8.3 二分查找算法")]),t._v(" "),r("h3",{attrs:{id:"_8-3-1二分查找："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-1二分查找："}},[t._v("#")]),t._v(" 8.3.1二分查找：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v('   请对一个有序数组进行二分查找 {1,8 10, 89, 10, 1234} ，输入一个数看该数组是否存在此数，并且求出下\n标，如果没有就提示"没有这个数"。\n')])])]),r("h3",{attrs:{id:"_8-3-2二分查找算法的思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-2二分查找算法的思路"}},[t._v("#")]),t._v(" 8.3.2二分查找算法的思路")]),t._v(" "),r("p",[r("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/1.jpg",alt:"二分查找思路"}})]),t._v(" "),r("h3",{attrs:{id:"_8-3-3二分查找的代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-3二分查找的代码"}},[t._v("#")]),t._v(" 8.3.3二分查找的代码")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v('说明：增加了找到所有的满足条件的元素下标:\n课后思考题： {1,8 10, 89, 10, 10，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数都查找到\n\npublic class BinarySearch {\n    public static void main(String[] args) {\n        int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };\n//        int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 };\n\n    }\n    // 二分查找算法\n    /**\n     *\n     * @param arr\n     *            数组\n     * @param left\n     *            左边的索引\n     * @param right\n     *            右边的索引\n     * @param findVal\n     *            要查找的值\n     * @return 如果找到就返回下标，如果没有找到，就返回 -1\n     */\n    public static int binarySearch(int[] arr, int left, int right, int findVal) {\n\n\n        // 当 left > right 时，说明递归整个数组，但是没有找到\n        if (left > right){\n            return -1;\n        }\n        int mid = (left + right) / 2;\n        int midVal = arr[mid];\n        if (findVal > midVal){\n            return binarySearch(arr,mid + 1,right,findVal);\n        }else if (findVal < midVal){\n            return binarySearch(arr, left, mid - 1, findVal);\n        }else {\n            return mid;\n        }\n\n    }\n\n    //完成一个课后思考题:\n    /*\n     * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，\n     * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000\n     *\n     * 思路分析\n     * 1. 在找到mid 索引值，不要马上返回\n     * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n     * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n     * 4. 将Arraylist返回\n     */\n\n    package com.lyg.eight;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    \n    /**\n     * @program: DataStructure\n     * @description:\n     * @author: LvYangai\n     * @create: 2020-07-05 15:49\n     * @e-mail: 1076977275@qq.com\n     **/\n    public class BinarySearch {\n        public static void main(String[] args) {\n            int arr[] = { 1, 8, 1000,1000, 89,1000,1000, 1234 };\n    //        int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 };\n            List<Integer> resIndexList = binarySearch2(arr, 0, arr.length - 1, 1000);\n            System.out.println("resIndexList=" + resIndexList);\n    \n        }\n        // 二分查找算法\n        /**\n         *\n         * @param arr\n         *            数组\n         * @param left\n         *            左边的索引\n         * @param right\n         *            右边的索引\n         * @param findVal\n         *            要查找的值\n         * @return 如果找到就返回下标，如果没有找到，就返回 -1\n         */\n        public static int binarySearch(int[] arr, int left, int right, int findVal) {\n    \n    \n            // 当 left > right 时，说明递归整个数组，但是没有找到\n            if (left > right){\n                return -1;\n            }\n            int mid = (left + right) / 2;\n            int midVal = arr[mid];\n            if (findVal > midVal){\n                return binarySearch(arr,mid + 1,right,findVal);\n            }else if (findVal < midVal){\n                return binarySearch(arr, left, mid - 1, findVal);\n            }else {\n                return mid;\n            }\n    \n        }\n    \n        //完成一个课后思考题:\n        /*\n         * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，\n         * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000\n         *\n         * 思路分析\n         * 1. 在找到mid 索引值，不要马上返回\n         * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n         * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n         * 4. 将Arraylist返回\n         */\n    \n        public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal) {\n    \n            System.out.println("hello~");\n            // 当 left > right 时，说明递归整个数组，但是没有找到\n            if (left > right) {\n                return new ArrayList<Integer>();\n            }\n            int mid = (left + right) / 2;\n            int midVal = arr[mid];\n    \n            if (findVal > midVal) { // 向 右递归\n                return binarySearch2(arr, mid + 1, right, findVal);\n            } else if (findVal < midVal) { // 向左递归\n                return binarySearch2(arr, left, mid - 1, findVal);\n            } else {\n    //\t\t\t * 思路分析\n    //\t\t\t * 1. 在找到mid 索引值，不要马上返回\n    //\t\t\t * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n    //\t\t\t * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n    //\t\t\t * 4. 将Arraylist返回\n    \n                List<Integer> resIndexlist = new ArrayList<Integer>();\n                //向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n                int temp = mid - 1;\n                while(temp >= 0) {\n                    if (arr[temp] != findVal) {//退出\n                        temp -= 1;\n                        continue;\n                    }\n                    //否则，就temp 放入到 resIndexlist\n                    resIndexlist.add(temp);\n                    temp -= 1; //temp左移\n                }\n                resIndexlist.add(mid);  //\n    \n                //向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList\n                temp = mid + 1;\n                while(temp < arr.length) {\n                    if (arr[temp] != findVal) {//退出\n                        temp += 1;\n                        continue;\n                    }\n                    //否则，就temp 放入到 resIndexlist\n                    resIndexlist.add(temp);\n                    temp += 1; //temp右移\n                }\n    \n                return resIndexlist;\n            }\n    \n        }\n    }\n')])])]),r("h2",{attrs:{id:"_8-4-插值查找算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-插值查找算法"}},[t._v("#")]),t._v(" 8.4 插值查找算法")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("1)插值查找原理介绍:\n 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。\n2)将折半查找中的求 mid 索引的公式, low表示左边索引left, high表示右边索引right. \n key就是前面我们讲的findVal\n")])])]),r("p",[r("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/2.jpg",alt:"插值公式"}}),t._v("\n3) int mid = low + (high-low) *(key - arr[low]) / (arr[high] - arr[low])\n对应前面的代码公式：\nint mid = left+(right–left)  *  (findVal – arr[left]) / (arr[right] – arr[left])\n4) 举例说明插值查找算法 1-100 的数组\n"),r("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/3.jpg",alt:"插值算法举例说明"}})]),t._v(" "),r("h3",{attrs:{id:"_8-4-1插值查找应用案例："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-1插值查找应用案例："}},[t._v("#")]),t._v(" 8.4.1插值查找应用案例：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v(' 请对一个有序数组进行插值查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下 \n标，如果没有就提示"没有这个数"。\n\n代码实现:\n\npublic class InsertValueSearch {\n\n    public static void main(String[] args) {\n\n//\t\tint [] arr = new int[100];\n//\t\tfor(int i = 0; i < 100; i++) {\n//\t\t\tarr[i] = i + 1;\n//\t\t}\n\n        int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };\n\n        int index = insertValueSearch(arr, 0, arr.length - 1, 1234);\n        //int index = binarySearch(arr, 0, arr.length, 1);\n        System.out.println("index = " + index);\n\n        //System.out.println(Arrays.toString(arr));\n    }\n\n    public static int binarySearch(int[] arr, int left, int right, int findVal) {\n        System.out.println("二分查找被调用~");\n        // 当 left > right 时，说明递归整个数组，但是没有找到\n        if (left > right) {\n            return -1;\n        }\n        int mid = (left + right) / 2;\n        int midVal = arr[mid];\n\n        if (findVal > midVal) { // 向 右递归\n            return binarySearch(arr, mid + 1, right, findVal);\n        } else if (findVal < midVal) { // 向左递归\n            return binarySearch(arr, left, mid - 1, findVal);\n        } else {\n\n            return mid;\n        }\n\n    }\n\n    //编写插值查找算法\n    //说明：插值查找算法，也要求数组是有序的\n    /**\n     *\n     * @param arr 数组\n     * @param left 左边索引\n     * @param right 右边索引\n     * @param findVal 查找值\n     * @return 如果找到，就返回对应的下标，如果没有找到，返回-1\n     */\n    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {\n\n        System.out.println("插值查找次数~~");\n\n        //注意：findVal < arr[0]  和  findVal > arr[arr.length - 1] 必须需要\n        //否则我们得到的 mid 可能越界\n        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {\n            return -1;\n        }\n\n        // 求出mid, 自适应\n        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n        int midVal = arr[mid];\n        if (findVal > midVal) { // 说明应该向右边递归\n            return insertValueSearch(arr, mid + 1, right, findVal);\n        } else if (findVal < midVal) { // 说明向左递归查找\n            return insertValueSearch(arr, left, mid - 1, findVal);\n        } else {\n            return mid;\n        }\n\n    }\n}\n')])])]),r("h3",{attrs:{id:"_8-4-2插值查找注意事项："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-2插值查找注意事项："}},[t._v("#")]),t._v(" 8.4.2插值查找注意事项：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v(" 1) 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找,    速度较快. \n 2) 关键字分布不均匀的情况下，该方法不一定比折半查找要好\n")])])]),r("h2",{attrs:{id:"_8-5-斐波那契-黄金分割法-查找算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-斐波那契-黄金分割法-查找算法"}},[t._v("#")]),t._v(" 8.5 斐波那契(黄金分割法)查找算法")]),t._v(" "),r("h3",{attrs:{id:"_8-5-1斐波那契-黄金分割法-查找基本介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-1斐波那契-黄金分割法-查找基本介绍"}},[t._v("#")]),t._v(" 8.5.1斐波那契(黄金分割法)查找基本介绍:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("1) 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 \n数字的近似值是  0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神\n奇的数字，会带来意向不大的效果。\n2) 斐波那契数列    {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数\n的比例，无限接近    黄金分割值 0.618\n")])])]),r("h3",{attrs:{id:"_8-5-2斐波那契-黄金分割法-原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-2斐波那契-黄金分割法-原理"}},[t._v("#")]),t._v(" 8.5.2斐波那契(黄金分割法)原理:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("   斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid  \n不再是中间或插值得到，而是位 于黄金分割点附近，即  mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示\n")])])]),r("p",[r("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AB%E7%AB%A0_files/4.jpg",alt:"斐波那契查找"}}),t._v("\n对 F(k-1)-1 的理解：\n1) 由斐波那契数列F[k]=F[k-1]+F[k-2]的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1。\n该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。\n从而中间位置为 mid=low+F(k-1)-1\n2) 类似的，每一子段也可以用相同的方式分割\n3) 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使\n得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1到F[k]-1 位置），\n都赋为 n 位置的值即可。\nwhile(n>fib(k)-1)\nk++;")]),t._v(" "),r("h3",{attrs:{id:"_8-5-3斐波那契查找应用案例："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-3斐波那契查找应用案例："}},[t._v("#")]),t._v(" 8.5.3斐波那契查找应用案例：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v('请对一个有序数组进行斐波那契查找{1,8,10,89,1000,1234}，输入一个数看看该数组是否存在此数，并且求 \n出下标，如果没有就提示"没有这个数"。 \n代码实现:\n\npublic class FibonacciSearch {\n\n\tpublic static int maxSize = 20;\n\tpublic static void main(String[] args) {\n\t\tint [] arr = {1,8, 10, 89, 1000, 1234};\n\t\t\n\t\tSystem.out.println("index=" + fibSearch(arr, 189));// 0\n\t\t\n\t}\n\n\t//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列\n\t//非递归方法得到一个斐波那契数列\n\tpublic static int[] fib() {\n\t\tint[] f = new int[maxSize];\n\t\tf[0] = 1;\n\t\tf[1] = 1;\n\t\tfor (int i = 2; i < maxSize; i++) {\n\t\t\tf[i] = f[i - 1] + f[i - 2];\n\t\t}\n\t\treturn f;\n\t}\n\t\n\t//编写斐波那契查找算法\n\t//使用非递归的方式编写算法\n\t/**\n\t * \n\t * @param a  数组\n\t * @param key 我们需要查找的关键码(值)\n\t * @return 返回对应的下标，如果没有-1\n\t */\n\tpublic static int fibSearch(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length - 1;\n\t\tint k = 0; //表示斐波那契分割数值的下标\n\t\tint mid = 0; //存放mid值\n\t\tint f[] = fib(); //获取到斐波那契数列\n\t\t//获取到斐波那契分割数值的下标\n\t\twhile(high > f[k] - 1) {\n\t\t\tk++;\n\t\t}\n\t\t//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]\n\t\t//不足的部分会使用0填充\n\t\tint[] temp = Arrays.copyOf(a, f[k]);\n\t\t//实际上需求使用a数组最后的数填充 temp\n\t\t//举例:\n\t\t//temp = {1,8, 10, 89, 1000, 1234, 0, 0}  => {1,8, 10, 89, 1000, 1234, 1234, 1234,}\n\t\tfor(int i = high + 1; i < temp.length; i++) {\n\t\t\ttemp[i] = a[high];\n\t\t}\n\t\t\n\t\t// 使用while来循环处理，找到我们的数 key\n\t\twhile (low <= high) { // 只要这个条件满足，就可以找\n\t\t\tmid = low + f[k - 1] - 1;\n\t\t\tif(key < temp[mid]) { //我们应该继续向数组的前面查找(左边)\n\t\t\t\thigh = mid - 1;\n\t\t\t\t//为甚是 k--\n\t\t\t\t//说明\n\t\t\t\t//1. 全部元素 = 前面的元素 + 后边元素\n\t\t\t\t//2. f[k] = f[k-1] + f[k-2]\n\t\t\t\t//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]\n\t\t\t\t//即 在 f[k-1] 的前面继续查找 k--\n\t\t\t\t//即下次循环 mid = f[k-1-1]-1\n\t\t\t\tk--;\n\t\t\t} else if ( key > temp[mid]) { // 我们应该继续向数组的后面查找(右边)\n\t\t\t\tlow = mid + 1;\n\t\t\t\t//为什么是k -=2\n\t\t\t\t//说明\n\t\t\t\t//1. 全部元素 = 前面的元素 + 后边元素\n\t\t\t\t//2. f[k] = f[k-1] + f[k-2]\n\t\t\t\t//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]\n\t\t\t\t//4. 即在f[k-2] 的前面进行查找 k -=2\n\t\t\t\t//5. 即下次循环 mid = f[k - 1 - 2] - 1\n\t\t\t\tk -= 2;\n\t\t\t} else { //找到\n\t\t\t\t//需要确定，返回的是哪个下标\n\t\t\t\tif(mid <= high) {\n\t\t\t\t\treturn mid;\n\t\t\t\t} else {\n\t\t\t\t\treturn high;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);