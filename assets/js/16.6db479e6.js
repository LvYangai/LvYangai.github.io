(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{332:function(t,n,e){"use strict";e.r(n);var r=e(33),a=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"第-3-章-稀疏数组和队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第-3-章-稀疏数组和队列"}},[t._v("#")]),t._v(" 第 3 章 稀疏数组和队列")]),t._v(" "),e("h2",{attrs:{id:"_3-1-稀疏-sparseary-数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-稀疏-sparseary-数组"}},[t._v("#")]),t._v(" 3.1 稀疏 sparseary 数组")]),t._v(" "),e("h3",{attrs:{id:"_3-1-1先看一个实际的需求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1先看一个实际的需求"}},[t._v("#")]),t._v(" 3.1.1先看一个实际的需求")]),t._v(" "),e("blockquote",[e("p",[t._v("编写的五子棋程序中，有存盘退出和续上盘的功能。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/1.jpg",alt:"五子棋"}})]),t._v(" "),e("blockquote",[e("p",[t._v("因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据.->稀疏数组。")])]),t._v(" "),e("h3",{attrs:{id:"_3-12-基本介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-12-基本介绍"}},[t._v("#")]),t._v(" 3.12 基本介绍")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。\n稀疏数组的处理方法是:\n\t1) 记录数组一共有几行几列，有多少个不同的值\n\t2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模\n")])])]),e("blockquote",[e("p",[t._v("稀疏数组举例说明\n"),e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95//java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/2.jpg",alt:"举例说明"}})])]),t._v(" "),e("h3",{attrs:{id:"_3-13应用实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-13应用实例"}},[t._v("#")]),t._v(" 3.13应用实例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1) 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等)\n2) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数\n3) 整体思路分析\n")])])]),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/3.jpg",alt:"思路"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('package com.lyg.three;\n\n/**\n * @program: DataStructure\n * @description:  sparsearray(稀疏数组)\n * @author: LvYangai\n * @create: 2020-06-20 14:29\n * @e-mail: 1076977275@qq.com\n **/\npublic class SparseArray {\n\tpublic static void main(String[] args) {\n\t\t// 创建一个原始的二维数组 11 * 11\n\t\t// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子\n\t\tint chessArr1[][] = new int[11][11];\n\t\tchessArr1[1][2] = 1;\n\t\tchessArr1[2][3] = 2;\n\t\tchessArr1[4][5] = 2;\n\t\t// 输出原始的二维数组\n\t\tSystem.out.println("原始的二维数组~~");\n\t\tfor (int[] row : chessArr1) {\n\t\t\tfor (int data : row) {\n\t\t\t\tSystem.out.printf("%d\\t", data);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// 将二维数组 转 稀疏数组的思\n\t\t// 1. 先遍历二维数组 得到非0数据的个数\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif (chessArr1[i][j] != 0) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. 创建对应的稀疏数组\n\t\tint sparseArr[][] = new int[sum + 1][3];\n\t\t// 给稀疏数组赋值\n\t\tsparseArr[0][0] = 11;\n\t\tsparseArr[0][1] = 11;\n\t\tsparseArr[0][2] = sum;\n\n\t\t// 遍历二维数组，将非0的值存放到 sparseArr中\n\t\tint count = 0; //count 用于记录是第几个非0数据\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif (chessArr1[i][j] != 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tsparseArr[count][0] = i;\n\t\t\t\t\tsparseArr[count][1] = j;\n\t\t\t\t\tsparseArr[count][2] = chessArr1[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 输出稀疏数组的形式\n\t\tSystem.out.println();\n\t\tSystem.out.println("得到稀疏数组为~~~~");\n\t\tfor (int i = 0; i < sparseArr.length; i++) {\n\t\t\tSystem.out.printf("%d\\t%d\\t%d\\t\\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);\n\t\t}\n\t\tSystem.out.println();\n\n\t\t//将稀疏数组 --》 恢复成 原始的二维数组\n\t\t/*\n\t\t *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]\n\t\t\t2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.\n\t\t */\n\n\t\t//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组\n\n\t\tint chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];\n\n\t\t//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可\n\n\t\tfor(int i = 1; i < sparseArr.length; i++) {\n\t\t\tchessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n\t\t}\n\n\t\t// 输出恢复后的二维数组\n\t\tSystem.out.println();\n\t\tSystem.out.println("恢复后的二维数组");\n\n\t\tfor (int[] row : chessArr2) {\n\t\t\tfor (int data : row) {\n\t\t\t\tSystem.out.printf("%d\\t", data);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n')])])]),e("h2",{attrs:{id:"_3-2-队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-队列"}},[t._v("#")]),t._v(" 3.2 队列")]),t._v(" "),e("h3",{attrs:{id:"_3-21-队列的一个使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-21-队列的一个使用场景"}},[t._v("#")]),t._v(" 3.21 队列的一个使用场景")]),t._v(" "),e("blockquote",[e("p",[t._v("银行排队的案例:\n"),e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/4.jpg",alt:"银行排队"}})])]),t._v(" "),e("h3",{attrs:{id:"_3-2-2-队列介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-队列介绍"}},[t._v("#")]),t._v(" 3.2.2 队列介绍")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1) 队列是一个有序列表，可以用数组或是链表来实现。\n2) 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出\n3) 示意图：(使用数组模拟队列示意图)\n")])])]),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/5.jpg",alt:"队列"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队\n列的最大容量。\n   因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rea 分别记录队列前后端的下标，\nfront 会随着数据输出而改变，而 rea 则是随着数据输入而改变，如图所示:\n")])])]),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/6.jpg",alt:"队列2"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("当我们将数据存入队列时称为”adQue”，adQue 的处理需要有两个步骤：思路分析\n   1) 将尾指针往后移：rea+1 , 当 front = rea 【空】\n   2) 若尾指针 rea 小于队列的最大下标 maxSize-1，则将数据存入 rea 所指的数组元素中，否则无法存入数据。\nrea = maxSize - 1[队列满]\n")])])]),e("blockquote",[e("p",[t._v("代码实现(数组模拟队列)")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('package com.lyg.three;\n\nimport java.util.Scanner;\n\n/**\n * @program: DataStructure\n * @description: 使用数组模拟队列\n * @author: LvYangai\n * @create: 2020-06-20 15:41\n * @e-mail: 1076977275@qq.com\n **/\npublic class ArrayQueueDemo {\n\tpublic static void main(String[] args) {\n\t\t//测试一下\n\t\t//创建一个队列\n\t\tArrayQueue queue = new ArrayQueue(3);\n\t\tchar key = \' \';//接收用户输入\n\t\tScanner in = new Scanner(System.in);\n\t\tboolean loop = true;\n\t\t//输出一个菜单\n\t\twhile (loop){\n\t\t\tSystem.out.println("s(show): 显示队列");\n\t\t\tSystem.out.println("e(exit): 退出程序");\n\t\t\tSystem.out.println("a(add): 添加数据到队列");\n\t\t\tSystem.out.println("g(get): 从队列取出数据");\n\t\t\tSystem.out.println("h(head): 查看队列头的数据");\n\t\t\tkey = in.next().charAt(0);//接收一个字符\n\t\t\tswitch (key) {\n\t\t\t\tcase \'s\':\n\t\t\t\t\tqueue.showQueue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'a\':\n\t\t\t\t\tSystem.out.println("输出一个数");\n\t\t\t\t\tint value = in.nextInt();\n\t\t\t\t\tqueue.addQueue(value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'g\': //取出数据\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint res = queue.getQueue();\n\t\t\t\t\t\tSystem.out.printf("取出的数据是%d\\n", res);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t// TODO: handle exception\n\t\t\t\t\t\tSystem.out.println(e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'h\': //查看队列头的数据\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint res = queue.headQueue();\n\t\t\t\t\t\tSystem.out.printf("队列头的数据是%d\\n", res);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t// TODO: handle exception\n\t\t\t\t\t\tSystem.out.println(e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \'e\': //退出\n\t\t\t\t\tin.close();\n\t\t\t\t\tloop = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println("程序退出");\n\t}\n}\nclass ArrayQueue{\n\tprivate int maxSize;//数组最大容量\n\tprivate int front;//队列头\n\tprivate int rear;//队列尾\n\tprivate int[] arr;//该数据用于存放数据，模拟队列\n\n\t//创建队列构造器\n\tpublic ArrayQueue(int maxSize) {\n\t\tthis.maxSize = maxSize;\n\t\tarr = new int[maxSize];\n\t\tfront = -1;//指向队列头部，队列头但前一个位置  如果为0代表有数据了；\n\t\trear = -1;//指向队列尾部，指向队列尾部数据（即就是队列数据最后一个数据）\n\t}\n\t//判断队列是否满\n\tpublic boolean isFull(){\n\t\treturn rear == maxSize - 1;\n\t}\n\t//判断队列是否为空\n\tpublic boolean isEmpty(){\n\t\treturn rear == front;\n\t}\n\t//添加数据到队列\n\tpublic void addQueue(int n){\n\t\t//判断队列是否满\n\t\tif (isFull()){\n\t\t\tSystem.out.println("队列满，不能加入数据~");\n\t\t\treturn;\n\t\t}\n\t\tarr[++rear] = n;\n\t\tSystem.out.println(rear);\n\t}\n\t//获取队列数据，出队列\n\tpublic int getQueue(){\n\t\t//判断队列是否为空\n\t\tif(isEmpty()){\n\t\t\tthrow new RuntimeException("队列空，不能取数据");\n\t\t}\n\t\treturn arr[++front];//front后移\n\t}\n\t//显示队列所有数据\n\tpublic void showQueue(){\n\t\t//遍历\n\t\tif (isEmpty()){\n\t\t\tSystem.out.println("队列空，没有数据～～");\n\t\t\treturn;\n\t\t}\n\t\tfor (int i=0; i<arr.length; i++){\n\t\t\tSystem.out.printf("arr[%d] = %d\\n",i,arr[i]);\n\t\t}\n\t}\n\t//显示队列但头部数据，注意不是取出数据\n\tpublic int headQueue(){\n\t\t//判断\n\t\tif (isEmpty()){\n\t\t\tthrow new RuntimeException("队列空，不能取数据");\n\t\t}\n\t\treturn arr[front + 1];\n\t}\n}\n')])])]),e("blockquote",[e("p",[t._v("问题分析并优化")])]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("目前数组使用一次就不能用， 没有达到复用的效果")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("将这个数组使用算法，改进成一个环形的队列 取模：%")])])])]),t._v(" "),e("h3",{attrs:{id:"_3-24-数组模拟环形队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-24-数组模拟环形队列"}},[t._v("#")]),t._v(" 3.24 数组模拟环形队列")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)\n")])])]),e("blockquote",[e("p",[t._v("分析说明：")])]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的\n时候需要注意 (rea + 1) % maxSize = front 满]")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("rea = front [空]")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("分析示意图:")])])])]),t._v(" "),e("p",[e("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0_files/7.jpg",alt:"改进数组"}})]),t._v(" "),e("blockquote",[e("p",[t._v("代码实现")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('package com.lyg.three;\n\nimport java.util.Scanner;\n\n/**\n * @program: DataStructure\n * @description: 使用环形数组模拟队列\n * @author: LvYangai\n * @create: 2020-06-20 16:44\n * @e-mail: 1076977275@qq.com\n **/\npublic class CircleArrayQueueDemo {\n    public static void main(String[] args) {\n        //测试一把\n        System.out.println("测试数组模拟环形队列的案例~~~");\n\n        // 创建一个环形队列\n        CircleArray queue = new CircleArray(4); //说明设置4, 其队列的有效数据最大是3\n        char key = \' \'; // 接收用户输入\n        Scanner scanner = new Scanner(System.in);//\n        boolean loop = true;\n        // 输出一个菜单\n        while (loop) {\n            System.out.println("s(show): 显示队列");\n            System.out.println("e(exit): 退出程序");\n            System.out.println("a(add): 添加数据到队列");\n            System.out.println("g(get): 从队列取出数据");\n            System.out.println("h(head): 查看队列头的数据");\n            key = scanner.next().charAt(0);// 接收一个字符\n            switch (key) {\n                case \'s\':\n                    queue.showQueue();\n                    break;\n                case \'a\':\n                    System.out.println("输出一个数");\n                    int value = scanner.nextInt();\n                    queue.addQueue(value);\n                    break;\n                case \'g\': // 取出数据\n                    try {\n                        int res = queue.getQueue();\n                        System.out.printf("取出的数据是%d\\n", res);\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case \'h\': // 查看队列头的数据\n                    try {\n                        int res = queue.headQueue();\n                        System.out.printf("队列头的数据是%d\\n", res);\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                        System.out.println(e.getMessage());\n                    }\n                    break;\n                case \'e\': // 退出\n                    scanner.close();\n                    loop = false;\n                    break;\n                default:\n                    break;\n            }\n        }\n        System.out.println("程序退出~~");\n\n    }\n}\nclass CircleArray{\n    private int maxSize; // 表示数组的最大容量\n    //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素\n    //front 的初始值 = 0\n    private int front;\n    //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.\n    //rear 的初始值 = 0\n    private int rear; // 队列尾\n    private int[] arr; // 该数据用于存放数据, 模拟队列\n\n    public CircleArray(int arrMaxSize) {\n        maxSize = arrMaxSize;\n        arr = new int[maxSize];\n    }\n\n    // 判断队列是否满\n    public boolean isFull() {\n        return (rear  + 1) % maxSize == front;\n    }\n\n    // 判断队列是否为空\n    public boolean isEmpty() {\n        return rear == front;\n    }\n\n    // 添加数据到队列\n    public void addQueue(int n) {\n        // 判断队列是否满\n        if (isFull()) {\n            System.out.println("队列满，不能加入数据~");\n            return;\n        }\n        //直接将数据加入\n        arr[rear] = n;\n        //将 rear 后移, 这里必须考虑取模\n        rear = (rear + 1) % maxSize;\n    }\n\n    // 获取队列的数据, 出队列\n    public int getQueue() {\n        // 判断队列是否空\n        if (isEmpty()) {\n            // 通过抛出异常\n            throw new RuntimeException("队列空，不能取数据");\n        }\n        // 这里需要分析出 front是指向队列的第一个元素\n        // 1. 先把 front 对应的值保留到一个临时变量\n        // 2. 将 front 后移, 考虑取模\n        // 3. 将临时保存的变量返回\n        int value = arr[front];\n        front = (front + 1) % maxSize;\n        return value;\n\n    }\n\n    // 显示队列的所有数据\n    public void showQueue() {\n        // 遍历\n        if (isEmpty()) {\n            System.out.println("队列空的，没有数据~~");\n            return;\n        }\n        // 思路：从front开始遍历，遍历多少个元素\n        // 动脑筋\n        for (int i = front; i < front + size() ; i++) {\n            System.out.printf("arr[%d]=%d\\n", i % maxSize, arr[i % maxSize]);\n        }\n    }\n\n    // 求出当前队列有效数据的个数\n    public int size() {\n        // rear = 2\n        // front = 1\n        // maxSize = 3\n        return (rear + maxSize - front) % maxSize;\n    }\n\n    // 显示队列的头数据， 注意不是取出数据\n    public int headQueue() {\n        // 判断\n        if (isEmpty()) {\n            throw new RuntimeException("队列空的，没有数据~~");\n        }\n        return arr[front];\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);