(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{341:function(t,n,a){"use strict";a.r(n);var r=a(33),e=Object(r.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第六章-递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第六章-递归"}},[t._v("#")]),t._v(" 第六章 递归")]),t._v(" "),a("h2",{attrs:{id:"_6-1-递归应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-递归应用场景"}},[t._v("#")]),t._v(" 6.1 递归应用场景")]),t._v(" "),a("blockquote",[a("p",[t._v("看个实际应用场景，迷宫问题(回溯)， 递归(Recursion)\n"),a("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AD%E7%AB%A0_files/1.jpg",alt:"递归迷宫"}})])]),t._v(" "),a("h2",{attrs:{id:"_6-2-递归的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-递归的概念"}},[t._v("#")]),t._v(" 6.2 递归的概念")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("   简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时\n可以让代码变得简洁。\n")])])]),a("h2",{attrs:{id:"_6-3-递归调用机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-递归调用机制"}},[t._v("#")]),t._v(" 6.3 递归调用机制")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("我列举两个小案例,来帮助大家理解递归，部分学员已经学习过递归了，这里在给大家回顾一下递归调用机制\n1) 打印问题\n2) 阶乘问题\n3) 使用图解方式说明了递归的调用机制\n")])])]),a("p",[a("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AD%E7%AB%A0_files/2.jpg",alt:"递归"}}),t._v("\n4）代码演示")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('package com.lyg.six;\n\n/**\n * @program: DataStructure\n * @description: 递归基本概念\n * @author: LvYangai\n * @create: 2020-07-01 14:26\n * @e-mail: 1076977275@qq.com\n **/\npublic class RecursionTest {\n    public static void main(String[] args) {\n\n       test(4);\n       int res = factorial(3);\n        System.out.println("res:"+res);\n    }\n\n    private static int factorial(int n) {\n        if (n == 1){\n            return 1;\n        }else {\n            return factorial(n-1) * n;\n        }\n    }\n\n    public static void test(int n){\n        if (n > 2){\n            test(n - 1);\n        }\n        System.out.println("n=" + n);\n    }\n\n}\n')])])]),a("h2",{attrs:{id:"_6-4-递归能解决什么样的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-递归能解决什么样的问题"}},[t._v("#")]),t._v(" 6.4 递归能解决什么样的问题")]),t._v(" "),a("blockquote",[a("p",[t._v("递归用于解决什么样的问题")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1)各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(gogle 编程大赛)\n2)各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.\n3)将用栈解决的问题--\x3e第归代码比较简洁\n")])])]),a("h2",{attrs:{id:"_6-5-递归需要遵守的重要规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-递归需要遵守的重要规则"}},[t._v("#")]),t._v(" 6.5 递归需要遵守的重要规则")]),t._v(" "),a("blockquote",[a("p",[t._v("递归需要遵守的重要规则")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)\n2) 方法的局部变量是独立的，不会相互影响, 比如 n 变量\n3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowEr\n3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowEro，死龟了:)\n5) 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或\n   者返回时，该方法也就执行完毕\n")])])]),a("h2",{attrs:{id:"_6-递归-迷宫问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-递归-迷宫问题"}},[t._v("#")]),t._v(" 6. 递归-迷宫问题")]),t._v(" "),a("h3",{attrs:{id:"_6-6-1迷宫问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-1迷宫问题"}},[t._v("#")]),t._v(" 6.6.1迷宫问题")]),t._v(" "),a("p",[a("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AD%E7%AB%A0_files/3.jpg",alt:"迷宫图解"}})]),t._v(" "),a("h3",{attrs:{id:"_6-2代码实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2代码实现"}},[t._v("#")]),t._v(" 6.2代码实现:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('package com.atguigu.recursion;\n\npublic class MiGong {\n\n\tpublic static void main(String[] args) {\n\t\t// 先创建一个二维数组，模拟迷宫\n\t\t// 地图\n\t\tint[][] map = new int[8][7];\n\t\t// 使用1 表示墙\n\t\t// 上下全部置为1\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tmap[0][i] = 1;\n\t\t\tmap[7][i] = 1;\n\t\t}\n\n\t\t// 左右全部置为1\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tmap[i][0] = 1;\n\t\t\tmap[i][6] = 1;\n\t\t}\n\t\t//设置挡板, 1 表示\n\t\tmap[3][1] = 1;\n\t\tmap[3][2] = 1;\n//\t\tmap[1][2] = 1;\n//\t\tmap[2][2] = 1;\n\t\t\n\t\t// 输出地图\n\t\tSystem.out.println("地图的情况");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + " ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\t//使用递归回溯给小球找路\n\t\t//setWay(map, 1, 1);\n\t\tsetWay2(map, 1, 1);\n\t\t\n\t\t//输出新的地图, 小球走过，并标识过的递归\n\t\tSystem.out.println("小球走过，并标识过的 地图的情况");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + " ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\t\n\t//使用递归回溯来给小球找路\n\t//说明\n\t//1. map 表示地图\n\t//2. i,j 表示从地图的哪个位置开始出发 (1,1)\n\t//3. 如果小球能到 map[6][5] 位置，则说明通路找到.\n\t//4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通\n\t//5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯\n\t/**\n\t * \n\t * @param map 表示地图\n\t * @param i 从哪个位置开始找\n\t * @param j \n\t * @return 如果找到通路，就返回true, 否则返回false\n\t */\n\tpublic static boolean setWay(int[][] map, int i, int j) {\n\t\tif(map[6][5] == 2) { // 通路已经找到ok\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif(map[i][j] == 0) { //如果当前这个点还没有走过\n\t\t\t\t//按照策略 下->右->上->左  走\n\t\t\t\tmap[i][j] = 2; // 假定该点是可以走通.\n\t\t\t\tif(setWay(map, i+1, j)) {//向下走\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (setWay(map, i, j+1)) { //向右走\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (setWay(map, i-1, j)) { //向上\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (setWay(map, i, j-1)){ // 向左走\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t//说明该点是走不通，是死路\n\t\t\t\t\tmap[i][j] = 3;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else { // 如果map[i][j] != 0 , 可能是 1， 2， 3\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//修改找路的策略，改成 上->右->下->左\n\tpublic static boolean setWay2(int[][] map, int i, int j) {\n\t\tif(map[6][5] == 2) { // 通路已经找到ok\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif(map[i][j] == 0) { //如果当前这个点还没有走过\n\t\t\t\t//按照策略 上->右->下->左\n\t\t\t\tmap[i][j] = 2; // 假定该点是可以走通.\n\t\t\t\tif(setWay2(map, i-1, j)) {//向上走\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (setWay2(map, i, j+1)) { //向右走\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (setWay2(map, i+1, j)) { //向下\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (setWay2(map, i, j-1)){ // 向左走\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t//说明该点是走不通，是死路\n\t\t\t\t\tmap[i][j] = 3;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else { // 如果map[i][j] != 0 , 可能是 1， 2， 3\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n}\n')])])]),a("h3",{attrs:{id:"_6-6-3对迷宫问题的讨论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-3对迷宫问题的讨论"}},[t._v("#")]),t._v(" 6.6.3对迷宫问题的讨论")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1) 小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关\n2) 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看路径是不是有变化\n3) 测试回溯现象\n4) 思考:如何求出最短路径?\t思路-》代码实现.\n")])])]),a("h2",{attrs:{id:"_6-7递归-八皇后问题-回溯算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7递归-八皇后问题-回溯算法"}},[t._v("#")]),t._v(" 6.7递归-八皇后问题(回溯算法)")]),t._v(" "),a("h3",{attrs:{id:"_6-7-1八皇后问题介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-1八皇后问题介绍"}},[t._v("#")]),t._v(" 6.7.1八皇后问题介绍")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("   八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 \n1848年提出：在  8×8  格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、\n同一列或同一斜线上，问有多少种摆法(92)。\n")])])]),a("p",[a("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AD%E7%AB%A0_files/4.jpg",alt:"八皇后"}})]),t._v(" "),a("h2",{attrs:{id:"_6-7-2八皇后问题算法思路分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-2八皇后问题算法思路分析"}},[t._v("#")]),t._v(" 6.7.2八皇后问题算法思路分析")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1)       第一个皇后先放第一行第一列 \n2)       第二个皇后放在第二行第一列、然后判断是否  OK，   如果不  OK，继续放在第二列、第三列、依次把所有列都 放完，找到一个合适 \n3)       继续第三个皇后，还是第一列、第二列……直到第  8  个皇后也能放在一个不冲突的位置，算是找到了一个正确 解 \n4)       当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到\n5)       然后回头继续第一个皇后放第二列，后面继续循环执行   1,2,3,4  的步骤 \n6)       示意图:\n")])])]),a("p",[a("img",{attrs:{src:"/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AC%AC%E5%85%AD%E7%AB%A0_files/5.jpg",alt:"八皇后图解"}})]),t._v(" "),a("blockquote",[a("p",[t._v("说明：\n理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. ar[8] =\n{0 , 4 7, 5 2, 6 1, 3} /对应 ar 下标 表示第几行，即第几个皇后，ar[i] = val , val 表示第 i+1 个皇后，放在第 i+1\n行的第 val+1 列")])]),t._v(" "),a("h3",{attrs:{id:"_6-73八皇后问题算法代码实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-73八皇后问题算法代码实现"}},[t._v("#")]),t._v(" 6.73八皇后问题算法代码实现")]),t._v(" "),a("blockquote",[a("p",[t._v("说明：看老师的代码演示")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('package com.lyg.six;\n\n/**\n * @program: DataStructure\n * @description: 八皇后\n * @author: LvYangai\n * @create: 2020-07-02 12:50\n * @e-mail: 1076977275@qq.com\n **/\npublic class Queue8 {\n\n    //定义一个max表示共有多少个皇后\n    int max = 8;\n    //定义数组array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3}\n    int[] array = new int[max];\n    static int count = 0;\n    static int judgeCount = 0;\n    public static void main(String[] args) {\n        //测试一把 ， 8皇后是否正确\n        Queue8 queue8 = new Queue8();\n        queue8.check(0);\n        System.out.printf("一共有%d解法\\n", count);\n        System.out.printf("一共判断冲突的次数%d次", judgeCount); // 1.5w\n\n    }\n\n\n    //编写一个方法，放置第n个皇后\n    //特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i < max; i++)，因此会有回溯\n    private void check(int n) {\n        if(n == max) {  //n = 8 , 其实8个皇后就既然放好\n            print();\n            return;\n        }\n\n        //依次放入皇后，并判断是否冲突\n        for(int i = 0; i < max; i++) {\n            //先把当前这个皇后 n , 放到该行的第1列\n            array[n] = i;\n            //判断当放置第n个皇后到i列时，是否冲突\n            if(judge(n)) { // 不冲突\n                //接着放n+1个皇后,即开始递归\n                check(n+1); //\n            }\n            //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置\n        }\n    }\n\n    //查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突\n    /**\n     *\n     * @param n 表示第n个皇后\n     * @return\n     */\n    private boolean judge(int n) {\n        judgeCount++;\n        for(int i = 0; i < n; i++) {\n            // 说明\n            //1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列\n            //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线\n            // n = 1  放置第 2列 1 n = 1 array[1] = 1\n            // Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1\n            //3. 判断是否在同一行, 没有必要，n 每次都在递增\n            if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //写一个方法，可以将皇后摆放的位置输出\n    private void print() {\n        count++;\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + " ");\n        }\n        System.out.println();\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=e.exports}}]);