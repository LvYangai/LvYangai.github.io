(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{329:function(t,e,n){"use strict";n.r(e);var r=n(33),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_05-servlet："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_05-servlet："}},[t._v("#")]),t._v(" 05.Servlet：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1. Servlet\n2. HTTP协议\n3. Request\n")])])]),n("h2",{attrs:{id:"servlet："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#servlet："}},[t._v("#")]),t._v(" Servlet：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('1. 概念\n2. 步骤\n3. 执行原理\n4. 生命周期\n5. Servlet3.0 注解配置\n6. Servlet的体系结构\t\n\tServlet -- 接口\n\t\t|\n\tGenericServlet -- 抽象类\n\t\t|\n\tHttpServlet  -- 抽象类\n\n\t* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象\n\t\t* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可\n\n\t* HttpServlet：对http协议的一种封装，简化操作\n\t\t1. 定义类继承HttpServlet\n\t\t2. 复写doGet/doPost方法\n\n7. Servlet相关配置\n\t1. urlpartten:Servlet访问路径\n\t\t1. 一个Servlet可以定义多个访问路径 ： @WebServlet({"/d4","/dd4","/ddd4"})\n\t\t2. 路径定义规则：\n\t\t\t1. /xxx：路径匹配\n\t\t\t2. /xxx/xxx:多层路径，目录结构\n\t\t\t3. *.do：扩展名匹配\n')])])]),n("h2",{attrs:{id:"http："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http："}},[t._v("#")]),t._v(" HTTP：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("* 概念：Hyper Text Transfer Protocol 超文本传输协议\n\t* 传输协议：定义了，客户端和服务器端通信时，发送数据的格式\n\t* 特点：\n\t\t1. 基于TCP/IP的高级协议\n\t\t2. 默认端口号:80\n\t\t3. 基于请求/响应模型的:一次请求对应一次响应\n\t\t4. 无状态的：每次请求之间相互独立，不能交互数据\n\n\t* 历史版本：\n\t\t* 1.0：每一次请求响应都会建立新的连接\n\t\t* 1.1：复用连接\n\n* 请求消息数据格式\n\t1. 请求行\n\t\t请求方式 请求url 请求协议/版本\n\t\tGET /login.html\tHTTP/1.1\n\n\t\t* 请求方式：\n\t\t\t* HTTP协议有7中请求方式，常用的有2种\n\t\t\t\t* GET：\n\t\t\t\t\t1. 请求参数在请求行中，在url后。\n\t\t\t\t\t2. 请求的url长度有限制的\n\t\t\t\t\t3. 不太安全\n\t\t\t\t* POST：\n\t\t\t\t\t1. 请求参数在请求体中\n\t\t\t\t\t2. 请求的url长度没有限制的\n\t\t\t\t\t3. 相对安全\n\t2. 请求头：客户端浏览器告诉服务器一些信息\n\t\t请求头名称: 请求头值\n\t\t* 常见的请求头：\n\t\t\t1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息\n\t\t\t\t* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题\n\n\t\t\t2. Referer：http://localhost/login.html\n\t\t\t\t* 告诉服务器，我(当前请求)从哪里来？\n\t\t\t\t\t* 作用：\n\t\t\t\t\t\t1. 防盗链：\n\t\t\t\t\t\t2. 统计工作：\n\t3. 请求空行\n\t\t空行，就是用于分割POST请求的请求头，和请求体的。\n\t4. 请求体(正文)：\n\t\t* 封装POST请求消息的请求参数的\n\n\t* 字符串格式：\n\t\tPOST /login.html\tHTTP/1.1\n\t\tHost: localhost\n\t\tUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0\n\t\tAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n\t\tAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\n\t\tAccept-Encoding: gzip, deflate\n\t\tReferer: http://localhost/login.html\n\t\tConnection: keep-alive\n\t\tUpgrade-Insecure-Requests: 1\n\t\t\n\t\tusername=zhangsan\t\n\n\n* 响应消息数据格式\n")])])]),n("h2",{attrs:{id:"request："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#request："}},[t._v("#")]),t._v(" Request：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('1. request对象和response对象的原理\n\t1. request和response对象是由服务器创建的。我们来使用它们\n\t2. request对象是来获取请求消息，response对象是来设置响应消息\n\n2. request对象继承体系结构：\t\n\tServletRequest\t\t--\t接口\n\t\t|\t继承\n\tHttpServletRequest\t-- 接口\n\t\t|\t实现\n\torg.apache.catalina.connector.RequestFacade 类(tomcat)\n\n3. request功能：\n\t1. 获取请求消息数据\n\t\t1. 获取请求行数据\n\t\t\t* GET /day14/demo1?name=zhangsan HTTP/1.1\n\t\t\t* 方法：\n\t\t\t\t1. 获取请求方式 ：GET\n\t\t\t\t\t* String getMethod()  \n\t\t\t\t2. (*)获取虚拟目录：/day14\n\t\t\t\t\t* String getContextPath()\n\t\t\t\t3. 获取Servlet路径: /demo1\n\t\t\t\t\t* String getServletPath()\n\t\t\t\t4. 获取get方式请求参数：name=zhangsan\n\t\t\t\t\t* String getQueryString()\n\t\t\t\t5. (*)获取请求URI：/day14/demo1\n\t\t\t\t\t* String getRequestURI():\t\t/day14/demo1\n\t\t\t\t\t* StringBuffer getRequestURL()  :http://localhost/day14/demo1\n\n\t\t\t\t\t* URL:统一资源定位符 ： http://localhost/day14/demo1\t中华人民共和国\n\t\t\t\t\t* URI：统一资源标识符 : /day14/demo1\t\t\t\t\t共和国\n\t\t\t\t\n\t\t\t\t6. 获取协议及版本：HTTP/1.1\n\t\t\t\t\t* String getProtocol()\n\n\t\t\t\t7. 获取客户机的IP地址：\n\t\t\t\t\t* String getRemoteAddr()\n\t\t\t\t\n\t\t2. 获取请求头数据\n\t\t\t* 方法：\n\t\t\t\t* (*)String getHeader(String name):通过请求头的名称获取请求头的值\n\t\t\t\t* Enumeration<String> getHeaderNames():获取所有的请求头名称\n\t\t\t\n\t\t3. 获取请求体数据:\n\t\t\t* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数\n\t\t\t* 步骤：\n\t\t\t\t1. 获取流对象\n\t\t\t\t\t*  BufferedReader getReader()：获取字符输入流，只能操作字符数据\n\t\t\t\t\t*  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据\n\t\t\t\t\t\t* 在文件上传知识点后讲解\n\n\t\t\t\t2. 再从流对象中拿数据\n\t\t\t\n\t\t\t\n\t2. 其他功能：\n\t\t1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数\n\t\t\t1. String getParameter(String name):根据参数名称获取参数值    username=zs&password=123\n\t\t\t2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&hobby=game\n\t\t\t3. Enumeration<String> getParameterNames():获取所有请求的参数名称\n\t\t\t4. Map<String,String[]> getParameterMap():获取所有参数的map集合\n\n\t\t\t* 中文乱码问题：\n\t\t\t\t* get方式：tomcat 8 已经将get方式乱码问题解决了\n\t\t\t\t* post方式：会乱码\n\t\t\t\t\t* 解决：在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");\n\t\t\n\t\t\t\t\n\t\t2. 请求转发：一种在服务器内部的资源跳转方式\n\t\t\t1. 步骤：\n\t\t\t\t1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)\n\t\t\t\t2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) \n\n\t\t\t2. 特点：\n\t\t\t\t1. 浏览器地址栏路径不发生变化\n\t\t\t\t2. 只能转发到当前服务器内部资源中。\n\t\t\t\t3. 转发是一次请求\n\n\n\t\t3. 共享数据：\n\t\t\t* 域对象：一个有作用范围的对象，可以在范围内共享数据\n\t\t\t* request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据\n\t\t\t* 方法：\n\t\t\t\t1. void setAttribute(String name,Object obj):存储数据\n\t\t\t\t2. Object getAttitude(String name):通过键获取值\n\t\t\t\t3. void removeAttribute(String name):通过键移除键值对\n\n\t\t4. 获取ServletContext：\n\t\t\t* ServletContext getServletContext()\n')])])]),n("h2",{attrs:{id:"案例：用户登录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#案例：用户登录"}},[t._v("#")]),t._v(" 案例：用户登录")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("* 用户登录案例需求：\n\t1.编写login.html登录页面\n\t\tusername & password 两个输入框\n\t2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表\n\t3.使用JdbcTemplate技术封装JDBC\n\t4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您\n\t5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误\n\n\n* 分析\n")])])]),n("p",[n("img",{attrs:{src:"/java/javaweb/Servlet&Request&%E6%A1%88%E4%BE%8B_files/1.jpg",alt:""}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('* 开发步骤\n\t1. 创建项目，导入html页面，配置文件，jar包\n\t2. 创建数据库环境\n\t\tCREATE DATABASE day14;\n\t\tUSE day14;\n\t\tCREATE TABLE USER(\n\t\t\n\t\t\tid INT PRIMARY KEY AUTO_INCREMENT,\n\t\t\tusername VARCHAR(32) UNIQUE NOT NULL,\n\t\t\tPASSWORD VARCHAR(32) NOT NULL\n\t\t);\n\n\t3. 创建包cn.itcast.domain,创建类User\n\t\tpackage cn.itcast.domain;\n\t\t/**\n\t\t * 用户的实体类\n\t\t */\n\t\tpublic class User {\n\t\t\n\t\t    private int id;\n\t\t    private String username;\n\t\t    private String password;\n\t\t\n\t\t\n\t\t    public int getId() {\n\t\t        return id;\n\t\t    }\n\t\t\n\t\t    public void setId(int id) {\n\t\t        this.id = id;\n\t\t    }\n\t\t\n\t\t    public String getUsername() {\n\t\t        return username;\n\t\t    }\n\t\t\n\t\t    public void setUsername(String username) {\n\t\t        this.username = username;\n\t\t    }\n\t\t\n\t\t    public String getPassword() {\n\t\t        return password;\n\t\t    }\n\t\t\n\t\t    public void setPassword(String password) {\n\t\t        this.password = password;\n\t\t    }\n\t\t\n\t\t    @Override\n\t\t    public String toString() {\n\t\t        return "User{" +\n\t\t                "id=" + id +\n\t\t                ", username=\'" + username + \'\\\'\' +\n\t\t                ", password=\'" + password + \'\\\'\' +\n\t\t                \'}\';\n\t\t    }\n\t\t}\n\t4. 创建包cn.itcast.util,编写工具类JDBCUtils\n\t\tpackage cn.itcast.util;\n\n\t\timport com.alibaba.druid.pool.DruidDataSourceFactory;\n\t\t\n\t\timport javax.sql.DataSource;\n\t\timport javax.xml.crypto.Data;\n\t\timport java.io.IOException;\n\t\timport java.io.InputStream;\n\t\timport java.sql.Connection;\n\t\timport java.sql.SQLException;\n\t\timport java.util.Properties;\n\t\t\n\t\t/**\n\t\t * JDBC工具类 使用Durid连接池\n\t\t */\n\t\tpublic class JDBCUtils {\n\t\t\n\t\t    private static DataSource ds ;\n\t\t\n\t\t    static {\n\t\t\n\t\t        try {\n\t\t            //1.加载配置文件\n\t\t            Properties pro = new Properties();\n\t\t            //使用ClassLoader加载配置文件，获取字节输入流\n\t\t            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");\n\t\t            pro.load(is);\n\t\t\n\t\t            //2.初始化连接池对象\n\t\t            ds = DruidDataSourceFactory.createDataSource(pro);\n\t\t\n\t\t        } catch (IOException e) {\n\t\t            e.printStackTrace();\n\t\t        } catch (Exception e) {\n\t\t            e.printStackTrace();\n\t\t        }\n\t\t    }\n\t\t\n\t\t    /**\n\t\t     * 获取连接池对象\n\t\t     */\n\t\t    public static DataSource getDataSource(){\n\t\t        return ds;\n\t\t    }\n\t\t\n\t\t\n\t\t    /**\n\t\t     * 获取连接Connection对象\n\t\t     */\n\t\t    public static Connection getConnection() throws SQLException {\n\t\t        return  ds.getConnection();\n\t\t    }\n\t\t}\n\t5. 创建包cn.itcast.dao,创建类UserDao,提供login方法\n\t\t\n\t\tpackage cn.itcast.dao;\n\n\t\timport cn.itcast.domain.User;\n\t\timport cn.itcast.util.JDBCUtils;\n\t\timport org.springframework.dao.DataAccessException;\n\t\timport org.springframework.jdbc.core.BeanPropertyRowMapper;\n\t\timport org.springframework.jdbc.core.JdbcTemplate;\n\t\t\n\t\t/**\n\t\t * 操作数据库中User表的类\n\t\t */\n\t\tpublic class UserDao {\n\t\t\n\t\t    //声明JDBCTemplate对象共用\n\t\t    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\n\t\t\n\t\t    /**\n\t\t     * 登录方法\n\t\t     * @param loginUser 只有用户名和密码\n\t\t     * @return user包含用户全部数据,没有查询到，返回null\n\t\t     */\n\t\t    public User login(User loginUser){\n\t\t        try {\n\t\t            //1.编写sql\n\t\t            String sql = "select * from user where username = ? and password = ?";\n\t\t            //2.调用query方法\n\t\t            User user = template.queryForObject(sql,\n\t\t                    new BeanPropertyRowMapper<User>(User.class),\n\t\t                    loginUser.getUsername(), loginUser.getPassword());\n\t\t\n\t\t\n\t\t            return user;\n\t\t        } catch (DataAccessException e) {\n\t\t            e.printStackTrace();//记录日志\n\t\t            return null;\n\t\t        }\n\t\t    }\n\t\t}\n\t\n\t6. 编写cn.itcast.web.servlet.LoginServlet类\n\t\tpackage cn.itcast.web.servlet;\n\n\t\timport cn.itcast.dao.UserDao;\n\t\timport cn.itcast.domain.User;\n\t\t\n\t\timport javax.servlet.ServletException;\n\t\timport javax.servlet.annotation.WebServlet;\n\t\timport javax.servlet.http.HttpServlet;\n\t\timport javax.servlet.http.HttpServletRequest;\n\t\timport javax.servlet.http.HttpServletResponse;\n\t\timport java.io.IOException;\n\t\t\n\t\t\n\t\t@WebServlet("/loginServlet")\n\t\tpublic class LoginServlet extends HttpServlet {\n\t\t\n\t\t\n\t\t    @Override\n\t\t    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t        //1.设置编码\n\t\t        req.setCharacterEncoding("utf-8");\n\t\t        //2.获取请求参数\n\t\t        String username = req.getParameter("username");\n\t\t        String password = req.getParameter("password");\n\t\t        //3.封装user对象\n\t\t        User loginUser = new User();\n\t\t        loginUser.setUsername(username);\n\t\t        loginUser.setPassword(password);\n\t\t\n\t\t        //4.调用UserDao的login方法\n\t\t        UserDao dao = new UserDao();\n\t\t        User user = dao.login(loginUser);\n\t\t\n\t\t        //5.判断user\n\t\t        if(user == null){\n\t\t            //登录失败\n\t\t            req.getRequestDispatcher("/failServlet").forward(req,resp);\n\t\t        }else{\n\t\t            //登录成功\n\t\t            //存储数据\n\t\t            req.setAttribute("user",user);\n\t\t            //转发\n\t\t            req.getRequestDispatcher("/successServlet").forward(req,resp);\n\t\t        }\n\t\t\n\t\t    }\n\t\t\n\t\t    @Override\n\t\t    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t        this.doGet(req,resp);\n\t\t    }\n\t\t}\n\n\t7. 编写FailServlet和SuccessServlet类\n\t\t@WebServlet("/successServlet")\n\t\tpublic class SuccessServlet extends HttpServlet {\n\t\t    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t        //获取request域中共享的user对象\n\t\t        User user = (User) request.getAttribute("user");\n\t\t\n\t\t        if(user != null){\n\t\t            //给页面写一句话\n\t\t\n\t\t            //设置编码\n\t\t            response.setContentType("text/html;charset=utf-8");\n\t\t            //输出\n\t\t            response.getWriter().write("登录成功！"+user.getUsername()+",欢迎您");\n\t\t        }\n\t\t\n\t\t\n\t\t    }\t\t\n\n\n\t\t@WebServlet("/failServlet")\n\t\tpublic class FailServlet extends HttpServlet {\n\t\t    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t        //给页面写一句话\n\t\t\n\t\t        //设置编码\n\t\t        response.setContentType("text/html;charset=utf-8");\n\t\t        //输出\n\t\t        response.getWriter().write("登录失败，用户名或密码错误");\n\t\t\n\t\t    }\n\t\t\n\t\t    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t        this.doPost(request,response);\n\t\t    }\n\t\t}\n\n\n\n\t8. login.html中form表单的action路径的写法\n\t\t* 虚拟目录+Servlet的资源路径\n\n\t9. BeanUtils工具类，简化数据封装\n\t\t* 用于封装JavaBean的\n\t\t1. JavaBean：标准的Java类\n\t\t\t1. 要求：\n\t\t\t\t1. 类必须被public修饰\n\t\t\t\t2. 必须提供空参的构造器\n\t\t\t\t3. 成员变量必须使用private修饰\n\t\t\t\t4. 提供公共setter和getter方法\n\t\t\t2. 功能：封装数据\n\n\n\t\t2. 概念：\n\t\t\t成员变量：\n\t\t\t属性：setter和getter方法截取后的产物\n\t\t\t\t例如：getUsername() --\x3e Username--\x3e username\n\n\n\t\t3. 方法：\n\t\t\t1. setProperty()\n\t\t\t2. getProperty()\n\t\t\t3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);