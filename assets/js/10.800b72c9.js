(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{333:function(t,n,e){"use strict";e.r(n);var a=e(33),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_06-response"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_06-response"}},[t._v("#")]),t._v(" 06.Response")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1. HTTP协议：响应消息\n2. Response对象\n3. ServletContext对象\n")])])]),e("h2",{attrs:{id:"http协议："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http协议："}},[t._v("#")]),t._v(" HTTP协议：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1. 请求消息：客户端发送给服务器端的数据\n\t* 数据格式：\n\t\t1. 请求行\n\t\t2. 请求头\n\t\t3. 请求空行\n\t\t4. 请求体\n2. 响应消息：服务器端发送给客户端的数据\n\t* 数据格式：\n\t\t1. 响应行\n\t\t\t1. 组成：协议/版本 响应状态码 状态码描述\n\t\t\t2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。\n\t\t\t\t1. 状态码都是3位数字 \n\t\t\t\t2. 分类：\n\t\t\t\t\t1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码\n\t\t\t\t\t2. 2xx：成功。代表：200\n\t\t\t\t\t3. 3xx：重定向。代表：302(重定向)，304(访问缓存)\n\t\t\t\t\t4. 4xx：客户端错误。\n\t\t\t\t\t\t* 代表：\n\t\t\t\t\t\t\t* 404（请求路径没有对应的资源） \n\t\t\t\t\t\t\t* 405：请求方式没有对应的doXxx方法\n\t\t\t\t\t5. 5xx：服务器端错误。代表：500(服务器内部出现异常)\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t2. 响应头：\n\t\t\t1. 格式：头名称： 值\n\t\t\t2. 常见的响应头：\n\t\t\t\t1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式\n\t\t\t\t2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据\n\t\t\t\t\t* 值：\n\t\t\t\t\t\t* in-line:默认值,在当前页面内打开\n\t\t\t\t\t\t* attachment;filename=xxx：以附件形式打开响应体。文件下载\n\t\t3. 响应空行\n\t\t4. 响应体:传输的数据\n\n\n\t* 响应字符串格式\n\t\tHTTP/1.1 200 OK\n\t\tContent-Type: text/html;charset=UTF-8\n\t\tContent-Length: 101\n\t\tDate: Wed, 06 Jun 2018 07:08:42 GMT\n\n\t\t<html>\n\t\t  <head>\n\t\t    <title>$Title$</title>\n\t\t  </head>\n\t\t  <body>\n\t\t  hello , response\n\t\t  </body>\n\t\t</html>\n")])])]),e("h2",{attrs:{id:"response对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#response对象"}},[t._v("#")]),t._v(" Response对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("* 功能：设置响应消息\n\t1. 设置响应行\n\t\t1. 格式：HTTP/1.1 200 ok\n\t\t2. 设置状态码：setStatus(int sc) \n\t2. 设置响应头：setHeader(String name, String value) \n\t\t\n\t3. 设置响应体：\n\t\t* 使用步骤：\n\t\t\t1. 获取输出流\n\t\t\t\t* 字符输出流：PrintWriter getWriter()\n\n\t\t\t\t* 字节输出流：ServletOutputStream getOutputStream()\n\n\t\t\t2. 使用输出流，将数据输出到客户端浏览器\n\n\n* 案例：\n\t1. 完成重定向\n")])])]),e("p",[e("img",{attrs:{src:"/java/javaweb/Response_files/1.jpg",alt:"重定向"}}),t._v('\n* 重定向：资源跳转的方式\n* 代码实现：\n//1. 设置状态码为302\nresponse.setStatus(302);\n//2.设置响应头location\nresponse.setHeader("location","/day15/responseDemo2");')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('\t        //简单的重定向方法\n\t        response.sendRedirect("/day15/responseDemo2");\n\n\t\t* 重定向的特点:redirect\n\t\t\t1. 地址栏发生变化\n\t\t\t2. 重定向可以访问其他站点(服务器)的资源\n\t\t\t3. 重定向是两次请求。不能使用request对象来共享数据\n\t\t* 转发的特点：forward\n\t\t\t1. 转发地址栏路径不变\n\t\t\t2. 转发只能访问当前服务器下的资源\n\t\t\t3. 转发是一次请求，可以使用request对象来共享数据\n\t\t\n\t\t* forward 和  redirect 区别\n\t\t\t\n\t\t* 路径写法：\n\t\t\t1. 路径分类\n\t\t\t\t1. 相对路径：通过相对路径不可以确定唯一资源\n\t\t\t\t\t* 如：./index.html\n\t\t\t\t\t* 不以/开头，以.开头路径\n\n\t\t\t\t\t* 规则：找到当前资源和目标资源之间的相对位置关系\n\t\t\t\t\t\t* ./：当前目录\n\t\t\t\t\t\t* ../:后退一级目录\n\t\t\t\t2. 绝对路径：通过绝对路径可以确定唯一资源\n\t\t\t\t\t* 如：http://localhost/day15/responseDemo2\t\t/day15/responseDemo2\n\t\t\t\t\t* 以/开头的路径\n\n\t\t\t\t\t* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出\n\t\t\t\t\t\t* 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)\n\t\t\t\t\t\t\t* 建议虚拟目录动态获取：request.getContextPath()\n\t\t\t\t\t\t\t* <a> , <form> 重定向...\n\t\t\t\t\t\t* 给服务器使用：不需要加虚拟目录\n\t\t\t\t\t\t\t* 转发路径\n\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\n\t2. 服务器输出字符数据到浏览器\n\t\t* 步骤：\n\t\t\t1. 获取字符输出流\n\t\t\t2. 输出数据\n\n\t\t* 注意：\n\t\t\t* 乱码问题：\n\t\t\t\t1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1\n\t\t\t\t2. 设置该流的默认编码\n\t\t\t\t3. 告诉浏览器响应体使用的编码\n')])])]),e("p",[e("img",{attrs:{src:"/java/javaweb/Response_files/2.jpg",alt:"response乱码"}}),t._v('\n//简单的形式，设置编码，是在获取流之前设置\nresponse.setContentType("text/html;charset=utf-8");\n3. 服务器输出字节数据到浏览器\n* 步骤：\n1. 获取字节输出流\n2. 输出数据')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("\t4. 验证码\n\t\t1. 本质：图片\n\t\t2. 目的：防止恶意表单注册\n\t\t3. 代码：\n")])])]),e("p",[t._v("protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('    int width = 100;\n    int height = 50;\n\n    //1.创建一对象，在内存中图片(验证码图片对象)\n    BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n\n\n    //2.美化图片\n    //2.1 填充背景色\n    Graphics g = image.getGraphics();//画笔对象\n    g.setColor(Color.PINK);//设置画笔颜色\n    g.fillRect(0,0,width,height);\n\n    //2.2画边框\n    g.setColor(Color.BLUE);\n    g.drawRect(0,0,width - 1,height - 1);\n\n    String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789";\n    //生成随机角标\n    Random ran = new Random();\n\n    for (int i = 1; i <= 4; i++) {\n        int index = ran.nextInt(str.length());\n        //获取字符\n        char ch = str.charAt(index);//随机字符\n        //2.3写验证码\n        g.drawString(ch+"",width/5*i,height/2);\n    }\n\n\n    //2.4画干扰线\n    g.setColor(Color.GREEN);\n\n    //随机生成坐标点\n\n    for (int i = 0; i < 10; i++) {\n        int x1 = ran.nextInt(width);\n        int x2 = ran.nextInt(width);\n\n        int y1 = ran.nextInt(height);\n        int y2 = ran.nextInt(height);\n        g.drawLine(x1,y1,x2,y2);\n    }\n\n\n    //3.将图片输出到页面展示\n    ImageIO.write(image,"jpg",response.getOutputStream());\n')])])]),t._v(" "),e("h2",{attrs:{id:"servletcontext对象："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#servletcontext对象："}},[t._v("#")]),t._v(" ServletContext对象：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信\n2. 获取：\n\t1. 通过request对象获取\n\t\trequest.getServletContext();\n\t2. 通过HttpServlet获取\n\t\tthis.getServletContext();\n3. 功能：\n\t1. 获取MIME类型：\n\t\t* MIME类型:在互联网通信过程中定义的一种文件数据类型\n\t\t\t* 格式： 大类型/小类型   text/html\t\timage/jpeg\n\n\t\t* 获取：String getMimeType(String file)  \n\t2. 域对象：共享数据\n\t\t1. setAttribute(String name,Object value)\n\t\t2. getAttribute(String name)\n\t\t3. removeAttribute(String name)\n\n\t\t* ServletContext对象范围：所有用户所有请求的数据\n\t3. 获取文件的真实(服务器)路径\n\t\t1. 方法：String getRealPath(String path)  \n\t\t\t String b = context.getRealPath("/b.txt");//web目录下资源访问\n\t         System.out.println(b);\n\t\n\t        String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问\n\t        System.out.println(c);\n\t\n\t        String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问\n\t        System.out.println(a);\n')])])]),e("h2",{attrs:{id:"案例："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例："}},[t._v("#")]),t._v(" 案例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("* 文件下载需求：\n\t1. 页面显示超链接\n\t2. 点击超链接后弹出下载提示框\n\t3. 完成图片文件下载\n\n\n* 分析：\n\t1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求\n\t2. 任何资源都必须弹出下载提示框\n\t3. 使用响应头设置资源的打开方式：\n\t\t* content-disposition:attachment;filename=xxx\n\n\n* 步骤：\n\t1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename\n\t2. 定义Servlet\n\t\t1. 获取文件名称\n\t\t2. 使用字节输入流加载文件进内存\n\t\t3. 指定response的响应头： content-disposition:attachment;filename=xxx\n\t\t4. 将数据写出到response输出流\n\n\n* 问题：\n\t* 中文文件问题\n\t\t* 解决思路：\n\t\t\t1. 获取客户端使用的浏览器版本信息\n\t\t\t2. 根据不同的版本信息，设置filename的编码方式不同")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);